"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8],{6797:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"using-global-store","metadata":{"permalink":"/case-studies/using-global-store","editUrl":"https://github.com/modular-component/website/case-studies/using-global-store.md","source":"@site/case-studies/using-global-store.md","title":"Using an application global store","description":"In this case study, we see how you could integrate an Easy-Peasy-powered Redux store through","date":"2022-10-28T00:00:00.000Z","formattedDate":"October 28, 2022","tags":[{"label":"store","permalink":"/case-studies/tags/store"},{"label":"redux","permalink":"/case-studies/tags/redux"}],"readingTime":5.5,"hasTruncateMarker":true,"authors":[{"name":"J\xe9r\xe9mie van der Sande","title":"Maintainer of ModularComponent","url":"https://github.com/jvdsande","imageURL":"https://github.com/jvdsande.png","key":"jvdsande"}],"frontMatter":{"slug":"using-global-store","title":"Using an application global store","authors":"jvdsande","date":"2022-10-28T00:00:00.000Z","tags":["store","redux"]},"nextItem":{"title":"Using an i18n provider","permalink":"/case-studies/using-internationalization"}},"content":"In this case study, we see how you could integrate an [Easy-Peasy](https://easy-peasy.vercel.app/)-powered Redux store through\\na custom stage in your application.\\n\\n\x3c!--truncate--\x3e\\n\\nEasy-Peasy is a library built around Redux, which offers a clean API for creating and consuming a store. \\nIt is aimed at being consumed through hooks, and is therefore a good candidate for abstraction using a modular stage.\\n\\nThe default API allows exposing three hooks:\\n\\n- `useStore` gives you access at the raw store object, and can be used for non-reactive accesses to the store state \\n  inside effects or callbacks for instance,\\n- `useStoreState` takes a selector as parameter, and subscribes to the store changes, memoizing the result of the \\n  selector, and triggering a component update when the returned value changes,\\n- `useStoreAction` also takes a selector as parameter, but this time allows extracting specific _actions_ rather than _state values_.\\n  _actions_ in Easy-Peasy are functions mutating your store, using Redux\'s dispatch internally.\\n\\nThrough those three hooks, you have complete access to your store, and can easily subscribe to your store with fine-grained\\nreactivity.\\n\\n## What can be improved?\\n\\nBy default, the three store access hooks are available as exports from `easy-peasy` itself. However, those exports are \\ngeneric and have no knowledge of your store structure. If you are using TypeScript, it wouldn\'t give you any type hints\\nabout either your state or your actions.\\n\\nEasy-Peasy offers a solution to this limitation: the `createTypedHooks` function. This function takes your store definition \\nas a generic TypeScript parameter, and returns a set of hooks named exactly like the one exported by the package, but \\naware of your store\'s typing.\\n\\nAll is left to do is exports those new hooks, and import them whenever you need to interface a component with the store.\\n\\nHowever, as your project scales, imports can start to stack up at the start of your files, and depending on your setup, \\nimports to files in your codebase can quickly get messy with relative paths.\\n\\n## Improving things with `ModularComponent`\\n\\nWith a custom stage, we can allow any component to receive your typed store hooks, without needing a further import source.\\nIt\'s a good first step, and even though it does not bring tremendous value, cleaning up your codebase is always nice.\\n\\nHere is our custom stage function:\\n\\n```tsx \\nimport { ModularStage } from \'@modular-component/core\'\\nimport { createTypedHooks } from \'easy-peasy\'\\n\\nimport { model } from \'./store/model\'\\n\\nconst typedHooks = createTypedHooks<typeof model>()\\n\\nexport function store(): ModularStage<\'store\', () => typeof typedHooks> {\\n  return { field: \'store\', useStage: () => typedHooks }\\n}\\n```\\n\\nOur stage takes no parameter, as it always returns the same value. It acts as a provider.\\n\\nIts stage hook simply injects our hooks created with `createTypedHooks` in the `store` field.\\n\\nNow, whenever any component needs to consume our store, we can simply add\\na stage to our factory.\\n\\n```tsx\\nconst StoreAwareComponent = ModularComponent()\\n  .with(store())\\n  .with(lifecycle(({ store }) => {\\n    // Reactive value read\\n    const someValue = store.useStoreState((state) => state.someModel.someValue)\\n    \\n    // Action selection\\n    const someAction = store.useStoreAction((actions) => actions.someModel.someAction)\\n    \\n    // Full raw store access\\n    const Store = store.useStore()\\n    \\n    // Main usage of actions\\n    useEffect(() => {\\n      someAction()\\n    }, [someAction])\\n    \\n    // Alternate usage of actions and non-reactive value read\\n    const callback = useCallback(() => {\\n      const someSyncValue = Store.getState().someOtherModel.someSyncValue\\n      Store.getActions().someOtherModel.someOtherAction(someSyncValue)\\n    }, [Store])\\n  }))\\n```\\n\\n## Going a step further\\n\\nWhile what we achieved so far is already nice, we can improve things a bit to make our store even more straightforward to use.\\n\\nOne thing that I personally observed when using Easy-Peasy, is that I very rarely use the `useStoreAction` hook. The reason\\nfor this is that your actions are naturally immutable, so `useStoreAction` don\'t bring any memoization to the table. Furthermore,\\nwe have access to the entire store object through `useStore`, which gives us access to those same actions through `getActions()`.\\n\\nBecause of this, I use `useStoreState` a lot to _subscribe to values_, and then simply use `useStore` and pass the `Store`\\nobject itself around in my effects and callbacks. A nice side-effect from that is that I don\'t need to change my \\ndependency array if I\'m in need of a different actions later on in the same callback or effect.\\n\\nTaking inspiration from that, we could create an abstraction hook that would grant us access to the store with a slightly\\ndifferent API:\\n\\n```tsx\\n// Helper hook\\nfunction useEasyPeasy() {\\n  const raw = useStore()\\n\\n  return useMemo(() => ({ \\n    raw, \\n    act: raw.getActions,\\n    get: raw.getState, \\n    use: useStoreState\\n  }), [raw])\\n}\\n\\n// Usage in a component\\nconst store = useEasyPeasy()\\n\\n// Reactive value read\\nconst someValue = store.use((state) => state.someModel.someValue)\\n\\n// Action selection\\nconst someAction = store.act().someModel.someAction\\n\\n// Full raw store access\\nconst rawStore = store.raw\\n\\n// Main usage of actions\\nuseEffect(() => {\\n  someAction()\\n}, [someAction])\\n\\n// Alternate usage of actions and non-reactive value read\\nconst callback = useCallback(() => {\\n  const someSyncValue = store.get().someOtherModel.someSyncValue\\n  store.act().someOtherModel.someOtherAction(someSyncValue)\\n}, [store])\\n```\\n\\nAdmittedly this change is small and purely depends on one\'s tastes. For me, this is a tremendous upgrade in readability:\\n\\n- I like that now all my store functions are scoped to the `store` variable, instead of living in separate hooks that\\n  I need to import and invoke separately. This makes it a breeze when a component changes from only needing read access\\n  to the store to finally needing to call some actions.\\n- The fact that each store function type is a three-letter word reduces clutter in my lifecycle hooks while still conveying\\n  intent clearly: `use`/`get` for read access with or without reactivity, `act` for write access.\\n\\nAnd obviously, it translates easily to a modular stage, as it\'s a simple hook call.\\n\\n\\n```tsx \\nimport { ModularStage } from \'@modular-component/core\'\\nimport { useEasyPeasy } from \'./use-easy-peasy\'\\n\\nexport function store(): ModularStage<\'store\', typeof useEasyPeasy> {\\n  return { field: \'store\', useStage: useEasyPeasy }\\n}\\n```\\n\\nAnd here is what using it would look like in a component:\\n\\n```tsx\\nconst StoreAwareComponent = ModularComponent()\\n  .with(store())\\n  .with(lifecycle(({ store }) => {\\n    // Reactive value read\\n    const someValue = store.use((state) => state.someModel.someValue)\\n    \\n    // Action selection\\n    const someAction = store.act().someModel.someAction\\n    \\n    // Full raw store access\\n    const Store = store.raw\\n    \\n    // Main usage of actions\\n    useEffect(() => {\\n      someAction()\\n    }, [someAction])\\n    \\n    // Alternate usage of actions and non-reactive value read\\n    const callback = useCallback(() => {\\n      const someSyncValue = store.get().someOtherModel.someSyncValue\\n      store.act().someOtherModel.someOtherAction(someSyncValue)\\n    }, [store])\\n  }))\\n```\\n\\n## Conclusion\\n\\nThrough this simple example, we\'ve seen how `ModularComponent` can help you reduce clutter across your app by embracing\\nthe injection mechanism, making your factory the center point to connect your component to your application\'s context.\\n\\nYou can also check our other case study about [configuring your internationalization system as a stage](./using-internationalization.md)."},{"id":"using-internationalization","metadata":{"permalink":"/case-studies/using-internationalization","editUrl":"https://github.com/modular-component/website/case-studies/using-internationalization.md","source":"@site/case-studies/using-internationalization.md","title":"Using an i18n provider","description":"In this case study, we look at injecting a component localization data using i18next","date":"2022-10-22T00:00:00.000Z","formattedDate":"October 22, 2022","tags":[{"label":"i18n","permalink":"/case-studies/tags/i-18-n"}],"readingTime":4.415,"hasTruncateMarker":true,"authors":[{"name":"J\xe9r\xe9mie van der Sande","title":"Maintainer of ModularComponent","url":"https://github.com/jvdsande","imageURL":"https://github.com/jvdsande.png","key":"jvdsande"}],"frontMatter":{"slug":"using-internationalization","title":"Using an i18n provider","authors":"jvdsande","date":"2022-10-22T00:00:00.000Z","tags":["i18n"]},"prevItem":{"title":"Using an application global store","permalink":"/case-studies/using-global-store"}},"content":"In this case study, we look at injecting a component localization data using [`i18next`](https://www.i18next.com/)\\nand TypeScript to build a custom modular stage.\\n\\n\x3c!--truncate--\x3e\\n\\n`i18next` is a well known library for handling your application\'s internationalization needs. At it simplest, you feed\\nit with a map of key/value pairs for each language you want to support, and it provides you with a `t(key: string)` function\\nretrieving the correct value based on the currently configured language and the passed key.\\n\\nWhen using TypeScript, you can further configure it with the list of valid keys, to get both type safety and autocompletion.\\n\\nUsing prefixes, you can scope your keys, and `i18next` provides a `t` function generator taking a prefix as parameter\\nand allowing accessing prefixed keys by the rest of their identifier only: for instance, `my.component.title` and `my.component.subtitle`\\ncan be accessed through `t(\'title\')` and `t(\'subtitle\')` when `t` is generated with the `my.component` prefix.\\n\\n## `i18next`\'s `useTranslation` hook \\n\\n`i18next` also comes with a powerful React integration, through which you can retrieve your `t` functions from a hook\\nsubscribed to locale changes. Thanks to this hook integration, it becomes fairly easy to integrate as a modular stage.\\n\\nThe `useTranslation` hook returns three variables: a configured `t` function, the raw `i18n` object, and a `ready` boolean\\nused when dynamically loading translations.\\n\\n## Injecting the `t` function and other values\\n\\nRather than importing `useTranslation` from `i18next-react` everywhere localization is needed, we can take advantage of\\n`ModularComponent` injection system. In this case study, we will focus on the returned `t` function, but you could create\\na different stage function if you want to keep access to the `i18n` and `ready` values.\\n\\nFor our case, here is how we would create the custom stage:\\n\\n```tsx\\nimport { TFunction } from \'i18next\'\\nimport { useTranslation } from \'i18next-react\'\\n\\nexport function locale(): ModularComponent<\'locale\', TFunction<\'translation\'>> {\\n  return { \\n    field: \'locale\',\\n    useStage: () => useTranslation(\'translation\').t,\\n  }\\n}\\n```\\n\\nThis simple stage simply calls the `useTranslation` hook with the default namespace, and returns the `t` function. It then\\nstores it in the `locale` field in the arguments map.\\n\\nThis allows us to easily used localized strings in our other stages, such as the render stage:\\n\\n```tsx\\nconst AppTitle = ModularComponent()\\n  .with(locale())\\n  .with(render(({ locale }) => (\\n    <>\\n      <h1>{locale(\'components.app-title.title\')}</h1>\\n      <h2>{locale(\'components.app-title.subtitle\')}</h2>\\n    </>\\n  )))\\n```\\n\\n## Embracing component prefixes\\n\\nIn the previous component, we had to repeat part of the localized string selector twice. Using `useTranslation` directly,\\nwe could have gone around this by providing a `keyPrefix` configuration. \\n\\nWe can set up our stage to optionally take this prefix as parameter, allowing us to retrieve a scoped `t` function.\\n\\n```tsx\\nimport { TFunction, TFuncKey } from \'i18next\'\\nimport { useTranslation } from \'i18next-react\'\\n\\nexport function locale<Key extends TFuncKey<\'translation\'> = never>(\\n  key?: Key,\\n): ModularStage<\\n  \'locale\',\\n  () => [Key] extends [never] \\n    ? TFunction<\'translation\'> \\n    : TFunction<\'translation\', Key>\\n> {\\n  return {\\n    field: \'locale\',\\n    useStage: () => useTranslation(\'translation\', { keyPrefix: key }).t,\\n  }\\n}\\n```\\n\\nWith this, we can simplify our component implementation by moving the common prefix to the stage initialization:\\n\\n```tsx\\nconst AppTitle = ModularComponent()\\n  .with(locale(\'components.app-title\'))\\n  .with(render(({ locale }) => (\\n    <>\\n      <h1>{locale(\'title\')}</h1>\\n      <h2>{locale(\'subtitle\')}</h2>\\n    </>\\n  )))\\n```\\n\\nIt then becomes really easy to implement shared practices around the application, scoping locales to a component\'s path\\nfor instance.\\n\\n## Switching the localization data of an existing component\\n\\nSince it is possible to create new components by taking a previous component and replacing a stage, we can take\\nan existing component and change the locale\'s prefix to alter the rendered text. For instance, we could have a sub-page\\ntitle inherit the implementation of our main application title:\\n\\n```tsx\\nconst SubPageTitle = AppTitle.with(locale(\'components.sub-page-title\'))\\n```\\n\\nHowever, using the current setup for our stage, TypeScript will actually let us replace the prefix by any other valid\\ntranslation key, instead of limiting it to prefixes for which the same scoped keys exist. Here, we would like to\\nrestrict this, so that switching the prefix is only possible if it does not break the render.\\n\\nMost of the time, this is done automatically by TypeScript by comparing the result of the `useStage` function for the\\nprevious stage value and the newly passed value. However, in this case, the `TFunction` type is not strict enough to \\ncover our needs. But we can go around it by modifying slightly the type of the returned function when a key is set:\\n\\n```tsx\\nimport { TFunction, TFuncKey } from \'i18next\'\\nimport { useTranslation } from \'i18next-react\'\\n\\nexport function locale<Key extends TFuncKey<\'translation\'> = never>(\\n  key?: Key,\\n): ModularStage<\\n  \'locale\',\\n  () => [Key] extends [never] ? TFunction<\'translation\'> :\\n    // highlight-next-line\\n    | TFunction<\'translation\', Key>\\n    // highlight-next-line\\n    | ((key: TFuncKey<\'translation\', Key>) => string)\\n> {\\n  return {\\n    field: \'locale\',\\n    useStage: () => useTranslation(\'translation\', { keyPrefix: key }).t,\\n  }\\n}\\n```\\n\\nBy adding this stricter restriction through a union type, we keep the original behavior, but only prefixes yielding compatible sub-selectors will be accepted when replacing a stage.\\n\\n## Conclusion\\n\\nWith this localization stage, we get a very easy way to integrate localized strings inside our components, with the full\\ntype-safety offered by `i18next`. By lifting the prefix definition at the factory level, we also make it easy to put \\nbest practices in place for organizing our locales linked to our components.\\n\\nYou can also check our other case study about [configuring golabl store access as a stage](./using-global-store.md)."}]}')}}]);
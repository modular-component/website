"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[303],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(n),d=o,h=m["".concat(l,".").concat(d)]||m[d]||c[d]||r;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7504:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:1},i="The extension system",s={unversionedId:"extensions/reference",id:"extensions/reference",title:"The extension system",description:"ModularComponent aims to be a toolkit, and as such, it needs to be as agnostic as possible",source:"@site/docs/extensions/reference.md",sourceDirName:"extensions",slug:"/extensions/reference",permalink:"/docs/extensions/reference",draft:!1,editUrl:"https://github.com/modular-component/website/docs/extensions/reference.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Testing Components",permalink:"/docs/usage/testing-components"},next:{title:"Official extensions",permalink:"/docs/extensions/official/"}},l={},p=[{value:"Setting a name and a target argument",id:"setting-a-name-and-a-target-argument",level:2},{value:"Type-safe definition: the <code>createMethodRecord</code> helper",id:"type-safe-definition-the-createmethodrecord-helper",level:2},{value:"Transforming the argument before committing it to the map",id:"transforming-the-argument-before-committing-it-to-the-map",level:2},{value:"Telling TypeScript about a value transformation",id:"telling-typescript-about-a-value-transformation",level:2},{value:"Restricting the type of the passed value",id:"restricting-the-type-of-the-passed-value",level:2},{value:"Enabling multiple mode on a stage",id:"enabling-multiple-mode-on-a-stage",level:2}],u={toc:p};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"the-extension-system"},"The extension system"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," aims to be a toolkit, and as such, it needs to be as agnostic as possible\nof the application context. For this reason, the core factory only implements a single stage: ",(0,o.kt)("inlineCode",{parentName:"p"},"withRender"),",\nwhich is in fact a simple, traditional React function component."),(0,o.kt)("p",null,"Capabilities can then be added on a per-application basis, to construct a pipeline that\nmakes sense for a specific application context: adding a stage for connecting to a global\nstore, or for handling internationalization..."),(0,o.kt)("p",null,"Such capabilities are added through ",(0,o.kt)("strong",{parentName:"p"},"extensions"),". Extensions are configuration objects\ndetailing a new stage method to add to the pipeline."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Understanding stages")),(0,o.kt)("p",{parentName:"blockquote"},"Each stage of a pipeline receives ",(0,o.kt)("em",{parentName:"p"},"exactly one argument"),", that can take two forms:"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"A primitive value, array or object (",(0,o.kt)("em",{parentName:"li"},"but ",(0,o.kt)("strong",{parentName:"em"},"not a function")),") to inject as argument\nfor further stages,"),(0,o.kt)("li",{parentName:"ul"},"A hook receiving the current set of arguments and computing the value to add.")),(0,o.kt)("p",{parentName:"blockquote"},"If the value to inject should be a function, then it is mandatory to use the hook parameter\nto wrap the function, otherwise the factory wouldn't know if it should execute the function\nor pass it down as-is:"),(0,o.kt)("pre",{parentName:"blockquote"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"// This will fail, the factory will execute the function thinking it's a hook!\nModularComponent().withSomeFunction(myFunction)\n\n// This will work, the factory will execute the anonymous function as a hook,\n// and pass the returned function as argument for further stages\nModularComponent().withSomeFunction(() => myFunction)\n")),(0,o.kt)("p",{parentName:"blockquote"},"When executed, each stage modifies ",(0,o.kt)("em",{parentName:"p"},"exactly one argument")," in the shared arguments map.")),(0,o.kt)("h2",{id:"setting-a-name-and-a-target-argument"},"Setting a name and a target argument"),(0,o.kt)("p",null,"In order to add a new stage, we need to provide at the very least:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The name of the method to add to the factory (",(0,o.kt)("inlineCode",{parentName:"li"},"withLifecycle"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"withDefaultProps"),"...)"),(0,o.kt)("li",{parentName:"ul"},"The name of the argument modified by the stage (",(0,o.kt)("inlineCode",{parentName:"li"},"lifecycle"),", ",(0,o.kt)("inlineCode",{parentName:"li"},"props"),"...)")),(0,o.kt)("p",null,"Extensions are written as a map of method name to method configuration. For instance, the ",(0,o.kt)("inlineCode",{parentName:"p"},"withLifecycle"),"\ndefinition looks something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export const WithLifecycle = {\n  withLifecycle: {\n    field: 'lifecycle',\n  },\n} as const\n")),(0,o.kt)("p",null,"You can add as many stage methods as you want. Different stage methods can also impact\nthe same field if needed, for some advanced cases."),(0,o.kt)("h2",{id:"type-safe-definition-the-createmethodrecord-helper"},"Type-safe definition: the ",(0,o.kt)("inlineCode",{parentName:"h2"},"createMethodRecord")," helper"),(0,o.kt)("p",null,"To ensure the configuration you produce is valid, you can wrap it in ",(0,o.kt)("inlineCode",{parentName:"p"},"createMethodRecord")," exported\nby ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/core"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createMethodRecord } from '@modular-component/core'\n\nexport const WithLifecycle = createMethodRecord({\n  withLifecycle: {\n    field: 'lifecycle',\n  },\n} as const)\n")),(0,o.kt)("p",null,"Notice the ",(0,o.kt)("inlineCode",{parentName:"p"},"as const")," statement, making sure TypeScript narrows all\ntypes as much as possible. It is of paramount importance to always add this statement\nto ensure type inference works correctly. Otherwise, the ",(0,o.kt)("inlineCode",{parentName:"p"},"field")," parameter\ncould be inferred as ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),", polluting the complete arguments map."),(0,o.kt)("p",null,"If you provide a misconfigured method, the ",(0,o.kt)("inlineCode",{parentName:"p"},"createMethodRecord")," function\nwill reject the argument, letting you know right away."),(0,o.kt)("h2",{id:"transforming-the-argument-before-committing-it-to-the-map"},"Transforming the argument before committing it to the map"),(0,o.kt)("p",null,"This simple definition of a method is enough for mapping the result of a hook to an argument,\nor to map an arbitrary primitive, object or array to the argument, but it might not\nbe sufficient for other cases. For instance, the ",(0,o.kt)("inlineCode",{parentName:"p"},"withDefaultProps")," stage needs to take\ninto account existing props, without needing the user to pass them down manually each time."),(0,o.kt)("p",null,"For this purpose, a method can also receive a ",(0,o.kt)("inlineCode",{parentName:"p"},"transform")," configuration parameter, detailing\nhow to generate the final value that will be added to the arguments map."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"transform")," function receives two parameters: the current arguments map received from\nprevious stages, and the value passed down to the stage by the user. It then returns the\ntransformed value to add to the argument map."),(0,o.kt)("p",null,"For instance, here is a simplified definition for ",(0,o.kt)("inlineCode",{parentName:"p"},"withDefaultProps"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export const WithDefaultProps = createMethodRecord({\n  withDefaultProps: {\n    field: 'props',\n    transform: (args, defaultProps) => ({\n      ...defaultProps,\n      ...args.props,\n    }),\n  },\n} as const)\n")),(0,o.kt)("p",null,"The stage is configured to modify the ",(0,o.kt)("inlineCode",{parentName:"p"},"props")," field, and its custom transform function\nmerges the provided default props."),(0,o.kt)("p",null,"However, there is a mistake in the above transform function: the second parameter\nis the raw value passed down by the user: it can therefore be a function. When writing\na transform function, you need to account for this case manually. Here is a correct\nimplementation of the above transform:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export const WithDefaultProps = createMethodRecord({\n  withDefaultProps: {\n    field: 'props',\n    transform: (args, useDefaultProps) => ({\n      ...(typeof useDefaultProps === 'function'\n        ? useDefaultProps(args)\n        : useDefaultProps),\n      ...args.props,\n    }),\n  },\n} as const)\n")),(0,o.kt)("p",null,"Note how we also renamed the parameter to ",(0,o.kt)("inlineCode",{parentName:"p"},"useDefaultProps"),": as this can be a hook, we\nneed to name it accordingly to not break the rule of hooks here."),(0,o.kt)("p",null,"While this might seem cumbersome, it offers a great flexibility for writing extensions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"It gives the opportunity to manipulate the args passed down to the hook, if needed,"),(0,o.kt)("li",{parentName:"ul"},"It allows delaying or the call to the function to the transform function, which can\nfor instance decide not to call it at all based on previous arguments.")),(0,o.kt)("h2",{id:"telling-typescript-about-a-value-transformation"},"Telling TypeScript about a value transformation"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: this is currently the only part of ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," that is not 100% extensible,\nas it requires patching a shared interface in ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/core"),". Because of that,\nit is not possible to have two stages with the same name and a different transform in the\nsame application.")),(0,o.kt)("p",null,'Sometimes, the transformation that we want to apply on a value might change its type\nfrom the one passed as parameter. Unfortunately, as of TypeScript 4.8, there isn\'t\na way still to use "generic generic types". It is therefore not possible, as far as we can tell,\nto retrieve the type of the ',(0,o.kt)("inlineCode",{parentName:"p"},"transform")," configuration and use it to infer the final type\nof the argument."),(0,o.kt)("p",null,"The workaround implemented for now is an exposed interface, ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularStageTransform"),", that\ntakes a generic parameter and contains a map of transformed type. An extension package\ncan overload this interface to add the correct transform for the provided stage."),(0,o.kt)("p",null,"For instance, let's imagine a ",(0,o.kt)("inlineCode",{parentName:"p"},"withArray")," stage that wraps the passed value in an array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export const WithArray = createMethodRecord({\n  withArray: {\n    field: 'array',\n    transform: (args, useArray) => [\n      typeof useArray === 'function' ? useArray(args) : useArray,\n    ],\n  },\n} as const)\n")),(0,o.kt)("p",null,"Using it as-is, ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent().withArray('hello world')")," would incorrectly infer the\ntype of the ",(0,o.kt)("inlineCode",{parentName:"p"},"array")," argument as ",(0,o.kt)("inlineCode",{parentName:"p"},"string"),". We can help TypeScript along by extending the ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularStageTransform"),"\ntype:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"declare module '@modular-component/core' {\n  export interface ModularStageTransform<T> {\n    withArray: [T]\n  }\n}\n")),(0,o.kt)("p",null,"With this, TypeScript will correctly infer the type of our example to ",(0,o.kt)("inlineCode",{parentName:"p"},"[string]"),"!"),(0,o.kt)("h2",{id:"restricting-the-type-of-the-passed-value"},"Restricting the type of the passed value"),(0,o.kt)("p",null,"Specifically for TypeScript users, stage method configuration allows defining a type\nthat the passed value should match to be considered valid. This information will be\nsurfaced to the user, marking the stage call as incorrect if the value type do not match\nthe expected restriction."),(0,o.kt)("p",null,"For instance, we might want to restrict values passed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"withDefaultProps")," stage to\nonly accept objects, as any other value do not make sense here."),(0,o.kt)("p",null,"This is done through the ",(0,o.kt)("inlineCode",{parentName:"p"},"restrict")," property:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export const WithDefaultProps = createMethodRecord({\n  withDefaultProps: {\n    field: 'props',\n    transform: (args, useDefaultProps) => ({\n      ...(typeof useDefaultProps === 'function'\n        ? useDefaultProps(args)\n        : useDefaultProps),\n      ...args.props,\n    }),\n    restrict: {} as Record<string, unknown>,\n  },\n} as const)\n")),(0,o.kt)("p",null,"Note that the value passed to the ",(0,o.kt)("inlineCode",{parentName:"p"},"restrict")," configuration is not important, it will\nnever be used internally. What matters is ",(0,o.kt)("em",{parentName:"p"},"its type,")," that we force through the ",(0,o.kt)("inlineCode",{parentName:"p"},"as"),"\nstatement here."),(0,o.kt)("h2",{id:"enabling-multiple-mode-on-a-stage"},"Enabling multiple mode on a stage"),(0,o.kt)("p",null,"Sometimes, it does not make sense to reuse/modify the previous stage when calling the\nsame stage multiple times. Sometimes on the contrary, we want a stage to run multiple times\nat various places in our pipeline."),(0,o.kt)("p",null,"Let's take for example a ",(0,o.kt)("inlineCode",{parentName:"p"},"withDebug")," stage that logs the current args to the console,\nand optionally takes an empty function as parameter to serve as breakpoint:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"export const WithDebug = createMethodRecord({\n  field: 'debug',\n  multiple: true,\n  restrict: undefined,\n  transform: (args, useDebug) => {\n    if (typeof useDebug === 'function') {\n      useDebug(args)\n    } else {\n      console.log(args)\n    }\n  },\n})\n")),(0,o.kt)("p",null,"All that was needed here was adding the ",(0,o.kt)("inlineCode",{parentName:"p"},"multiple: true")," flag to our configuration."),(0,o.kt)("p",null,"From there on, calling ",(0,o.kt)("inlineCode",{parentName:"p"},"withDebug()")," multiple time on the same ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent"),"\nwill log the arguments gathered up until each debug stage."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Side note: ",(0,o.kt)("inlineCode",{parentName:"strong"},"restrict: undefined"))),(0,o.kt)("p",{parentName:"blockquote"},"Whenever ",(0,o.kt)("inlineCode",{parentName:"p"},"restrict: undefined")," is used on a stage method, the type\ndefinition will allow users to omit the argument completely, making ",(0,o.kt)("inlineCode",{parentName:"p"},"useDebug()"),"\na valid call instead of requiring ",(0,o.kt)("inlineCode",{parentName:"p"},"useDebug(undefined)"),". Useful for\nstages that return a constant value or only execute side-effects!")))}c.isMDXComponent=!0}}]);
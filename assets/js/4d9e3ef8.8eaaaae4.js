"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[8],{6797:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"using-global-store","metadata":{"permalink":"/case-studies/using-global-store","editUrl":"https://github.com/modular-component/website/case-studies/using-global-store.md","source":"@site/case-studies/using-global-store.md","title":"Using an application global store","description":"In this case study, we see how you could integrate an Easy-Peasy-powered Redux store through","date":"2022-10-28T00:00:00.000Z","formattedDate":"October 28, 2022","tags":[{"label":"store","permalink":"/case-studies/tags/store"},{"label":"redux","permalink":"/case-studies/tags/redux"}],"readingTime":5.81,"hasTruncateMarker":true,"authors":[{"name":"J\xe9r\xe9mie van der Sande","title":"Maintainer of ModularComponent","url":"https://github.com/jvdsande","imageURL":"https://github.com/jvdsande.png","key":"jvdsande"}],"frontMatter":{"slug":"using-global-store","title":"Using an application global store","authors":"jvdsande","date":"2022-10-28T00:00:00.000Z","tags":["store","redux"]},"nextItem":{"title":"Using an i18n provider","permalink":"/case-studies/using-internationalization"}},"content":"In this case study, we see how you could integrate an [Easy-Peasy](https://easy-peasy.vercel.app/)-powered Redux store through\\na custom stage in your application.\\n\\n\x3c!--truncate--\x3e\\n\\nEasy-Peasy is a library built around Redux, which offers a clean API for creating and consuming a store. \\nIt is aimed at being consumed through hooks, and is therefore a good candidate for abstraction using a modular stage.\\n\\nThe default API allows exposing three hooks:\\n\\n- `useStore` gives you access at the raw store object, and can be used for non-reactive accesses to the store state \\n  inside effects or callbacks for instance,\\n- `useStoreState` takes a selector as parameter, and subscribes to the store changes, memoizing the result of the \\n  selector, and triggering a component update when the returned value changes,\\n- `useStoreAction` also takes a selector as parameter, but this time allows extracting specific _actions_ rather than _state values_.\\n  _actions_ in Easy-Peasy are functions mutating your store, using Redux\'s dispatch internally.\\n\\nThrough those three hooks, you have complete access to your store, and can easily subscribe to your store with fine-grained\\nreactivity.\\n\\n## What can be improved?\\n\\nBy default, the three store access hooks are available as exports from `easy-peasy` itself. However, those exports are \\ngeneric and have no knowledge of your store structure. If you are using TypeScript, it wouldn\'t give you any type hints\\nabout either your state or your actions.\\n\\nEasy-Peasy offers a solution to this limitation: the `createTypedHooks` function. This function takes your store definition \\nas a generic TypeScript parameter, and returns a set of hooks named exactly like the one exported by the package, but \\naware of your store\'s typing.\\n\\nAll is left to do is exports those new hooks, and import them whenever you need to interface a component with the store.\\n\\nHowever, as your project scales, imports can start to stack up at the start of your files, and depending on your setup, \\nimports to files in your codebase can quickly get messy with relative paths.\\n\\n## Improving things with `ModularComponent`\\n\\nWith a custom stage, we can allow any component to receive your typed store hooks, without needing a further import.\\nIt\'s a good first step, and even though it does not bring tremendous value, cleaning up your codebase is always nice.\\n\\nHere is our custom stage definition:\\n\\n```tsx \\nimport { createStageRecord } from \'@modular-component/core\'\\nimport { createTypedHooks } from \'easy-peasy\'\\n\\nimport { model } from \'./store/model\'\\n\\nconst typedHooks = createTypedHooks<typeof model>()\\n\\nconst withStore = Symbol()\\n\\ndeclare module \'@modular-component/core\' {\\n  export interface ModularStages<Args, Value> {\\n    [withStore]: {\\n      restrict: undefined\\n      transform: typeof typedHooks\\n    }\\n  }\\n}\\n\\nexport const WithStore = createStageRecord({\\n  field: \'store\',\\n  symbol: withStore,\\n  transform: () => {\\n    return typedHooks\\n  }\\n})\\n```\\n\\nOur stage takes no parameter, as it always returns the same value. It acts as a provider. We instruct TypeScript to let\\nus call that stage without parameter through `restrict: undefined`.\\n\\nIts transform function simply inject our hooks created with `createTypedHooks`, in the `store` field.\\n\\nNow, whenever any component needs to consume our store, we don\'t need to worry about another import, we can simply add\\na stage to our factory.\\n\\n```tsx\\nconst StoreAwareComponent = ModularComponent()\\n  .withStore()\\n  .withLifecycle(({ store }) => {\\n    // Reactive value read\\n    const someValue = store.useStoreState((state) => state.someModel.someValue)\\n    \\n    // Action selection\\n    const someAction = store.useStoreAction((actions) => actions.someModel.someAction)\\n    \\n    // Full raw store access\\n    const Store = store.useStore()\\n    \\n    // Main usage of actions\\n    useEffect(() => {\\n      someAction()\\n    }, [someAction])\\n    \\n    // Alternate usage of actions and non-reactive value read\\n    const callback = useCallback(() => {\\n      const someSyncValue = Store.getState().someOtherModel.someSyncValue\\n      Store.getActions().someOtherModel.someOtherAction(someSyncValue)\\n    }, [Store])\\n  })\\n```\\n\\n## Going a step further\\n\\nWhile what we achieved so far is already nice, we can improve things a bit to make our store even more straightforward to use.\\n\\nOne thing that I personally observed when using Easy-Peasy, is that I very rarely use the `useStoreAction` hook. The reason\\nfor this is that your actions are naturally immutable, so `useStoreAction` don\'t bring any memoization to the table. Furthermore,\\nwe have access to the entire store object through `useStore`, which gives us access to those same actions through `getActions()`.\\n\\nBecause of this, I use `useStoreState` a lot to _subscribe to values_, and then simply use `useStore` and pass the `Store`\\nobject itself around in my effects and callbacks. A nice side-effect from that is that I don\'t need to change my \\ndependency array if I\'m in need of a different actions later on in the same callback or effect.\\n\\nTaking inspiration from that, we could create an abstraction hook that would grant us access to the store with a slightly\\ndifferent API:\\n\\n```tsx\\n// Helper hook\\nfunction useEasyPeasy() {\\n  const raw = useStore()\\n\\n  return useMemo(() => ({ \\n    raw, \\n    act: raw.getActions,\\n    get: raw.getState, \\n    use: useStoreState\\n  }), [raw])\\n}\\n\\n// Usage in a component\\nconst store = useEasyPeasy()\\n\\n// Reactive value read\\nconst someValue = store.use((state) => state.someModel.someValue)\\n\\n// Action selection\\nconst someAction = store.act().someModel.someAction\\n\\n// Full raw store access\\nconst rawStore = store.raw\\n\\n// Main usage of actions\\nuseEffect(() => {\\n  someAction()\\n}, [someAction])\\n\\n// Alternate usage of actions and non-reactive value read\\nconst callback = useCallback(() => {\\n  const someSyncValue = store.get().someOtherModel.someSyncValue\\n  store.act().someOtherModel.someOtherAction(someSyncValue)\\n}, [store])\\n```\\n\\nAdmittedly this change is small and purely depends on one\'s tastes. For me, this is a tremendous upgrade in readability:\\n\\n- I like that now all my store functions are scoped to the `store` variable, instead of living in separate hooks that\\n  I need to import and invoke separately. This makes it a breeze when a component changes from only needing read access\\n  to the store to finally needing to call some actions.\\n- The fact that each store function type is a three-letter word reduces clutter in my lifecycle hooks while still conveying\\n  intent clearly: `use`/`get` for read access with or without reactivity, `act` for write access.\\n\\nAnd obviously, it translates easily to a modular stage, as it\'s a simple hook call.\\n\\n\\n```tsx \\nimport { createStageRecord } from \'@modular-component/core\'\\nimport { useEasyPeasy } from \'./use-easy-peasy\'\\n\\nconst withStore = Symbol()\\n\\ndeclare module \'@modular-component/core\' {\\n  export interface ModularStageTransform<T> {\\n    [withStore]: {\\n      restrict: undefined\\n      transform: ReturnType<typeof useEasyPeasy>\\n    }\\n  }\\n}\\n\\nexport const WithStore = createStageRecord({\\n  field: \'store\',\\n  symbol: withStore,\\n  transform: useEasyPeasy\\n})\\n```\\n\\nAnd here is what using it would look like in a component:\\n\\n```tsx\\nconst StoreAwareComponent = ModularComponent()\\n  .withStore()\\n  .withLifecycle(({ store }) => {\\n    // Reactive value read\\n    const someValue = store.use((state) => state.someModel.someValue)\\n    \\n    // Action selection\\n    const someAction = store.act().someModel.someAction\\n    \\n    // Full raw store access\\n    const Store = store.raw\\n    \\n    // Main usage of actions\\n    useEffect(() => {\\n      someAction()\\n    }, [someAction])\\n    \\n    // Alternate usage of actions and non-reactive value read\\n    const callback = useCallback(() => {\\n      const someSyncValue = store.get().someOtherModel.someSyncValue\\n      store.act().someOtherModel.someOtherAction(someSyncValue)\\n    }, [store])\\n  })\\n```\\n\\n## Conclusion\\n\\nThrough this simple example, we\'ve seen how `ModularComponent` can help you reduce clutter across your app by embracing\\nthe injection mechanism, making your factory the only import needed to connect your component to your application\'s context.\\n\\nYou can also check our other case study about [configuring your internationalization system as a stage](./using-internationalization.md)."},{"id":"using-internationalization","metadata":{"permalink":"/case-studies/using-internationalization","editUrl":"https://github.com/modular-component/website/case-studies/using-internationalization.md","source":"@site/case-studies/using-internationalization.md","title":"Using an i18n provider","description":"In this case study, we look at injecting a component localization data using i18next","date":"2022-10-22T00:00:00.000Z","formattedDate":"October 22, 2022","tags":[{"label":"i18n","permalink":"/case-studies/tags/i-18-n"}],"readingTime":0.385,"hasTruncateMarker":true,"authors":[{"name":"J\xe9r\xe9mie van der Sande","title":"Maintainer of ModularComponent","url":"https://github.com/jvdsande","imageURL":"https://github.com/jvdsande.png","key":"jvdsande"}],"frontMatter":{"slug":"using-internationalization","title":"Using an i18n provider","authors":"jvdsande","date":"2022-10-22T00:00:00.000Z","tags":["i18n"]},"prevItem":{"title":"Using an application global store","permalink":"/case-studies/using-global-store"}},"content":"In this case study, we look at injecting a component localization data using [`i18next`](https://www.i18next.com/)\\nand TypeScript to build a custom modular stage.\\n\\n\x3c!--truncate--\x3e\\n\\n`i18next` is a well known library for handling your application\'s internationalization needs. At it simplest, you feed\\nit with a map of key/value pairs for each language you want to support, and it provides you with a `t(key: string)` function\\nretrieving the correct value based on the currently configured language and the passed key."}]}')}}]);
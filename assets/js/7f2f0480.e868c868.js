"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[310],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||r;return n?o.createElement(h,s(s({ref:t},u),{},{components:n})):o.createElement(h,s({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<r;c++)s[c]=n[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5418:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const r={slug:"using-global-store",title:"Using an application global store",authors:"jvdsande",date:new Date("2022-10-28T00:00:00.000Z"),tags:["store","redux"]},s=void 0,i={permalink:"/case-studies/using-global-store",editUrl:"https://github.com/modular-component/website/case-studies/using-global-store.md",source:"@site/case-studies/using-global-store.md",title:"Using an application global store",description:"In this case study, we see how you could integrate an Easy-Peasy-powered Redux store through",date:"2022-10-28T00:00:00.000Z",formattedDate:"October 28, 2022",tags:[{label:"store",permalink:"/case-studies/tags/store"},{label:"redux",permalink:"/case-studies/tags/redux"}],readingTime:5.94,hasTruncateMarker:!0,authors:[{name:"J\xe9r\xe9mie van der Sande",title:"Maintainer of ModularComponent",url:"https://github.com/jvdsande",imageURL:"https://github.com/jvdsande.png",key:"jvdsande"}],frontMatter:{slug:"using-global-store",title:"Using an application global store",authors:"jvdsande",date:"2022-10-28T00:00:00.000Z",tags:["store","redux"]},nextItem:{title:"Using an i18n provider",permalink:"/case-studies/using-internationalisation"}},l={authorsImageUrls:[void 0]},c=[{value:"What can be improved?",id:"what-can-be-improved",level:2},{value:"Improving things with <code>ModularComponent</code>",id:"improving-things-with-modularcomponent",level:2},{value:"Going a step further",id:"going-a-step-further",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"In this case study, we see how you could integrate an ",(0,a.kt)("a",{parentName:"p",href:"https://easy-peasy.vercel.app/"},"Easy-Peasy"),"-powered Redux store through\na custom stage in your application."),(0,a.kt)("p",null,"Easy-Peasy is a library built around Redux, which offers a clean API for creating and consuming a store.\nIt is aimed at being consumed through hooks, and is therefore a good candidate for abstraction using a modular stage."),(0,a.kt)("p",null,"The default API allows exposing three hooks:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"useStore")," gives you access at the raw store object, and can be used for non-reactive accesses to the store state\ninside effects or callbacks for instance,"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"useStoreState")," takes a selector as parameter, and subscribes to the store changes, memoizing the result of the\nselector, and triggering a component update when the returned value changes,"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"useStoreAction")," also takes a selector as parameter, but this time allows extracting specific ",(0,a.kt)("em",{parentName:"li"},"actions")," rather than ",(0,a.kt)("em",{parentName:"li"},"state values"),".\n",(0,a.kt)("em",{parentName:"li"},"actions")," in Easy-Peasy are functions mutating your store, using Redux's dispatch internally.")),(0,a.kt)("p",null,"Through those three hooks, you have complete access to your store, and can easily subscribe to your store with fine-grained\nreactivity."),(0,a.kt)("h2",{id:"what-can-be-improved"},"What can be improved?"),(0,a.kt)("p",null,"By default, the three store access hooks are available as exports from ",(0,a.kt)("inlineCode",{parentName:"p"},"easy-peasy")," itself. However, those exports are\ngeneric and have no knowledge of your store structure. If you are using TypeScript, it wouldn't give you any type hints\nabout either your state or your actions."),(0,a.kt)("p",null,"Easy-Peasy offers a solution to this limitation: the ",(0,a.kt)("inlineCode",{parentName:"p"},"createTypedHooks")," function. This function takes your store definition\nas a generic TypeScript parameter, and returns a set of hooks named exactly like the one exported by the package, but\naware of your store's typing."),(0,a.kt)("p",null,"All is left to do is exports those new hooks, and import them whenever you need to interface a component with the store."),(0,a.kt)("p",null,"However, as your project scales, imports can start to stack up at the start of your files, and depending on your setup,\nimports to files in your codebase can quickly get messy with relative paths."),(0,a.kt)("h2",{id:"improving-things-with-modularcomponent"},"Improving things with ",(0,a.kt)("inlineCode",{parentName:"h2"},"ModularComponent")),(0,a.kt)("p",null,"With a custom stage, we can allow any component to receive your typed store hooks, without needing a further import.\nIt's a good first step, and even though it does not bring tremendous value, cleaning up your codebase is always nice."),(0,a.kt)("p",null,"Here is our custom stage definition:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createStageRecord } from '@modular-component/core'\nimport { createTypedHooks } from 'easy-peasy'\n\nimport { model } from './store/model'\n\nconst typedHooks = createTypedHooks<typeof model>()\n\nconst withStore = Symbol()\n\nexport const WithStore = createStageRecord({\n  field: 'store',\n  symbol: withStore,\n  restrict: undefined,\n  transform: () => {\n    return typedHooks\n  }\n})\n\ndeclare module '@modular-component/core' {\n  export interface ModularStageTransform<T> {\n    [withStore]: typeof typedHooks\n  }\n}\n")),(0,a.kt)("p",null,"Our stage takes no parameter, as it always returns the same value. It acts as a provider. We instruct TypeScript to let\nus call that stage without parameter through ",(0,a.kt)("inlineCode",{parentName:"p"},"restrict: undefined"),"."),(0,a.kt)("p",null,"Its transform function simply inject our hooks created with ",(0,a.kt)("inlineCode",{parentName:"p"},"createTypedHooks"),", in the ",(0,a.kt)("inlineCode",{parentName:"p"},"store")," field."),(0,a.kt)("p",null,"Finally, we add an overload to ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularStageTransform")," to tell TypeScript what value is set to our field through our\ntransform function."),(0,a.kt)("p",null,"Now, whenever any component needs to consume our store, we don't need to worry about another import, we can simply add\na stage to our factory."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const StoreAwareComponent = ModularComponent()\n  .withStore()\n  .withLifecycle(({ store }) => {\n    // Reactive value read\n    const someValue = store.useStoreState((state) => state.someModel.someValue)\n    \n    // Action selection\n    const someAction = store.useStoreAction((actions) => actions.someModel.someAction)\n    \n    // Full raw store access\n    const Store = store.useStore()\n    \n    // Main usage of actions\n    useEffect(() => {\n      someAction()\n    }, [someAction])\n    \n    // Alternate usage of actions and non-reactive value read\n    const callback = useCallback(() => {\n      const someSyncValue = Store.getState().someOtherModel.someSyncValue\n      Store.getActions().someOtherModel.someOtherAction(someSyncValue)\n    }, [Store])\n  })\n")),(0,a.kt)("h2",{id:"going-a-step-further"},"Going a step further"),(0,a.kt)("p",null,"While what we achieved so far is already nice, we can improve things a bit to make our store even more straightforward to use."),(0,a.kt)("p",null,"One thing that I personally observed when using Easy-Peasy, is that I very rarely use the ",(0,a.kt)("inlineCode",{parentName:"p"},"useStoreAction")," hook. The reason\nfor this is that your actions are naturally immutable, so ",(0,a.kt)("inlineCode",{parentName:"p"},"useStoreAction")," don't bring any memoization to the table. Furthemore,\nwe have access to the entire store object through ",(0,a.kt)("inlineCode",{parentName:"p"},"useStore"),", which gives us access to those same actions through ",(0,a.kt)("inlineCode",{parentName:"p"},"getActions()"),"."),(0,a.kt)("p",null,"Because of this, I use ",(0,a.kt)("inlineCode",{parentName:"p"},"useStoreState")," a lot to ",(0,a.kt)("em",{parentName:"p"},"subscribe to values"),", and then simply use ",(0,a.kt)("inlineCode",{parentName:"p"},"useStore")," and pass the ",(0,a.kt)("inlineCode",{parentName:"p"},"Store"),"\nobject itself around in my effects and callbacks. A nice side-effect from that is that I don't need to change my\ndependency array if I'm in need of a different actions later on in the same callback or effect."),(0,a.kt)("p",null,"Taking inspiration from that, we could create an abstraction hook that would allow us access to the store with a slightly\ndifferent API:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// Helper hook\nfunction useEasyPeasy() {\n  const raw = useStore()\n  \n  const act = raw.getActions\n  const get = raw.getState\n  const use = useStoreState\n  \n  return useMemo(() => ({ raw, act, get, use }), [raw, act, get, use])\n}\n\n// Usage in a component\nconst store = useEasyPeasy()\n\n// Reactive value read\nconst someValue = store.use((state) => state.someModel.someValue)\n\n// Action selection\nconst someAction = store.act().someModel.someAction\n\n// Full raw store access\nconst rawStore = store.raw\n\n// Main usage of actions\nuseEffect(() => {\n  someAction()\n}, [someAction])\n\n// Alternate usage of actions and non-reactive value read\nconst callback = useCallback(() => {\n  const someSyncValue = store.get().someOtherModel.someSyncValue\n  store.act().someOtherModel.someOtherAction(someSyncValue)\n}, [store])\n")),(0,a.kt)("p",null,"Admittedly this change is small and purely depends on one's tastes. For me, this is a tremendous upgrade in readability:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"I like that now all my store functions are scoped to the ",(0,a.kt)("inlineCode",{parentName:"li"},"store")," variable, instead of living in separate hooks that\nI need to import and invoke separately. This makes it a breeze when a component changes from only needing read access\nto the store to finally needing to call some actions."),(0,a.kt)("li",{parentName:"ul"},"The fact that each store function type is a three-letter word reduces clutter in my lifecycle hooks while still conveying\nintent clearly: ",(0,a.kt)("inlineCode",{parentName:"li"},"use"),"/",(0,a.kt)("inlineCode",{parentName:"li"},"get")," for read access with or without reactivity, ",(0,a.kt)("inlineCode",{parentName:"li"},"act")," for write access.")),(0,a.kt)("p",null,"And obviously, it translates easily to a modular stage, as it's a simple hook call."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { createStageRecord } from '@modular-component/core'\nimport { useEasyPeasy } from './use-easy-peasy'\n\nconst withStore = Symbol()\n\nexport const WithStore = createStageRecord({\n  field: 'store',\n  symbol: withStore,\n  restrict: undefined,\n  transform: useEasyPeasy\n})\n\ndeclare module '@modular-component/core' {\n  export interface ModularStageTransform<T> {\n    [withStore]: ReturnType<typeof useEasyPeasy>\n  }\n}\n")),(0,a.kt)("p",null,"And here is what using it would look like in a component:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const StoreAwareComponent = ModularComponent()\n  .withStore()\n  .withLifecycle(({ store }) => {\n    // Reactive value read\n    const someValue = store.use((state) => state.someModel.someValue)\n    \n    // Action selection\n    const someAction = store.act().someModel.someAction\n    \n    // Full raw store access\n    const Store = store.raw\n    \n    // Main usage of actions\n    useEffect(() => {\n      someAction()\n    }, [someAction])\n    \n    // Alternate usage of actions and non-reactive value read\n    const callback = useCallback(() => {\n      const someSyncValue = store.get().someOtherModel.someSyncValue\n      store.act().someOtherModel.someOtherAction(someSyncValue)\n    }, [store])\n  })\n")),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"Through this simple example, we've seen how ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," can help you reduce clutter across your app by embracing\nthe injection mechanism, making your factory the only import needed to connect your component to your application's context."),(0,a.kt)("p",null,"You can also check our other case study about ",(0,a.kt)("a",{parentName:"p",href:"/case-studies/using-internationalisation"},"configuring your internationalization system as a stage"),"."))}p.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[222],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=a,g=u["".concat(s,".").concat(d)]||u[d]||m[d]||r;return n?o.createElement(g,i(i({ref:t},c),{},{components:n})):o.createElement(g,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8622:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const r={sidebar_position:1,title:"Writing Components"},i=void 0,l={unversionedId:"usage/writing-components",id:"usage/writing-components",title:"Writing Components",description:"All our guides are written in TypeScript, as ModularComponent was built from the ground up with TypeScript in mind.",source:"@site/docs/usage/writing-components.md",sourceDirName:"usage",slug:"/usage/writing-components",permalink:"/docs/usage/writing-components",draft:!1,editUrl:"https://github.com/modular-component/website/docs/usage/writing-components.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,title:"Writing Components"},sidebar:"tutorialSidebar",previous:{title:"ModularComponent",permalink:"/docs/intro"},next:{title:"Writing Hooks",permalink:"/docs/usage/writing-hooks"}},s={},p=[{value:"Configuring the component",id:"configuring-the-component",level:2},{value:"Component display name",id:"component-display-name",level:3},{value:"Component properties",id:"component-properties",level:3},{value:"Adding stages",id:"adding-stages",level:2},{value:"Custom stages",id:"custom-stages",level:3},{value:"Render stage",id:"render-stage",level:3}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"All our guides are written in TypeScript, as ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," was built from the ground up with TypeScript in mind.\nHowever, it is perfectly possible to take advantage of ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," with standard JavaScript.")),(0,a.kt)("h2",{id:"configuring-the-component"},"Configuring the component"),(0,a.kt)("p",null,"At it simplest, a component is created by calling the factory:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ModularComponent } from './modular-component'\n\nexport const MyComponent = ModularComponent()\n")),(0,a.kt)("p",null,"This is enough to get a valid, instantiable component. However, this component will do nothing: it does not handle\nany state, and renders ",(0,a.kt)("inlineCode",{parentName:"p"},"null")," by default."),(0,a.kt)("h3",{id:"component-display-name"},"Component display name"),(0,a.kt)("p",null,"One caveat of working with ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," is that React cannot infer its display name from the variable it is assigned too,\nbecause the actual component is created inside the factory. This can make debugging trickier, as stack traces and React Devtools\nwill show all components as anonymous components."),(0,a.kt)("p",null,"You can get around this limitation by manually providing an (optional) display name at component creation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ModularComponent } from './modular-component'\n\nexport const MyComponent = ModularComponent('MyComponent')\n")),(0,a.kt)("p",null,"It is a good practice to keep the debug name and the variable name in sync."),(0,a.kt)("h3",{id:"component-properties"},"Component properties"),(0,a.kt)("p",null,"When using TypeScript, you can pass a generic type parameter to the ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," call to set the component's props:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ModularComponent } from './modular-component'\n\nexport const MyComponent = ModularComponent<{\n  isActive: boolean\n  label: string\n}>()\n")),(0,a.kt)("p",null,"The props typing will be passed along in each stage, and will also be used for the final typing of the component itself, so\nthat TypeScript knows about them when instantiating it."),(0,a.kt)("h2",{id:"adding-stages"},"Adding stages"),(0,a.kt)("p",null,"Now that our component is created, we can ",(0,a.kt)("strong",{parentName:"p"},"add stages")," to it to extend its capabilities. The result of the factory is a usable React ",(0,a.kt)("inlineCode",{parentName:"p"},"FunctionComponent"),",\non which custom factory methods have been added. To add a stage to our component, we can use the ",(0,a.kt)("inlineCode",{parentName:"p"},".with()")," method. "),(0,a.kt)("p",null,"Note that ",(0,a.kt)("strong",{parentName:"p"},"component factories")," are immutable. Because of this, you need to chain the stage calls in the same\nassignment as your component creation. You ",(0,a.kt)("em",{parentName:"p"},"cannot call them as side-effects"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// \u26a0\ufe0f This will not work - `with(stage)` call returns a modified \n//    component but does not touch the original one\nconst MyComponent = ModularComponent()\n\nMyComponent.with(stage())\n\n// \u2705 Do this instead - save the result of the `with(stage)` call\n//    as your component\nconst MyComponent = ModularComponent()\n  .with(stage())\n")),(0,a.kt)("p",null,"This will come in very handy in the next chapter about ",(0,a.kt)("a",{parentName:"p",href:"/docs/usage/reusing-components"},"extending and reusing components"),", as well as for\n",(0,a.kt)("a",{parentName:"p",href:"/docs/usage/testing-components"},"testing components")),(0,a.kt)("h3",{id:"custom-stages"},"Custom stages"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},".with()")," method accepts a standard object comprised of two fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"field"),": the name of the argument that will get added to the argument map"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"useStage"),": a hook that receives the current argument map and returns the value to set on the stage field")),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"While it's possible to use those objects directly when calling ",(0,a.kt)("inlineCode",{parentName:"p"},".with()"),", for readability and ease of writing we\nrecommend creation ",(0,a.kt)("strong",{parentName:"p"},"custom stage functions")," that take relevant parameters and abstract away the stage logic."),(0,a.kt)("p",{parentName:"admonition"},"All our ",(0,a.kt)("a",{parentName:"p",href:"/docs/extensions/official/"},"official extensions")," are actually this kind of functions.")),(0,a.kt)("p",null,"When calling ",(0,a.kt)("inlineCode",{parentName:"p"},".with()"),", each stage will add or modify\na field on the shared ",(0,a.kt)("strong",{parentName:"p"},"argument map"),", consolidating data that can be consumed by further stages."),(0,a.kt)("p",null,"The order of stages is therefore important: only data from stages appearing ",(0,a.kt)("em",{parentName:"p"},"higher in the list")," will be available in\nany given stage."),(0,a.kt)("p",null,"Generic stages (handling default props, injecting localization data...) should come first in the pipeline. If needed,\nwe can then add a lifecycle stage handling the component's logic. Our component could look something like that:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyComponent = ModularComponent()\n  .with(globalStore())\n  .with(locale('localization.key.for.my.component'))\n  .with(lifecycle(({ locale, store }) => {\n    useDocumentTitle(locale('title'))\n    \n    const someStoreValue = store.useState((store) => store.some.value)\n    const [someInternalValue] = React.useState('value')\n    \n    return { someStoreValue, someInternalValue }\n  }))\n")),(0,a.kt)("h3",{id:"render-stage"},"Render stage"),(0,a.kt)("p",null,"Finally, we can close our component by adding a ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," stage. Stages setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," field are special\nbecause the factory will look for it internally. As such, any stage ",(0,a.kt)("em",{parentName:"p"},"downstream")," of a ",(0,a.kt)("inlineCode",{parentName:"p"},"render")," stage will be ignored\nwhen rendering as a component."),(0,a.kt)("p",null,"Render stages need to return a valid React node, as their return will be used as the return value of the complete component.\nThis is enforced internally at the TypeScript level."),(0,a.kt)("p",null,"Building on top of our previous example, this is what our component could look like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyComponent = ModularComponent()\n  .with(globalStore())\n  .with(locale('localization.key.for.my.component'))\n  .with(lifecycle(({ locale, store }) => {\n    useDocumentTitle(locale('title'))\n    \n    const someStoreValue = store.useState((store) => store.some.value)\n    const [someInternalValue] = React.useState('value')\n    \n    return { someStoreValue, someInternalValue }\n  }))\n  .with(render(({ locale, lifecycle }) => (\n    <>\n      <h1>{locale('title')}</h1>\n      <p>{locale('content')}</p>\n      <p>Value from store: {lifecycle.someStoreValue}</p>\n      <p>Value from state: {lifecycle.someInternalValue}</p>\n    </>\n  )))\n")))}m.isMDXComponent=!0}}]);
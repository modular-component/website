"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6921],{948:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"usage/writing-components","title":"Writing Components","description":"All our guides are written in TypeScript, as ModularComponent was built from the ground up with TypeScript in mind.","source":"@site/docs/usage/writing-components.md","sourceDirName":"usage","slug":"/usage/writing-components","permalink":"/docs/usage/writing-components","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/usage/writing-components.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Writing Components"},"sidebar":"defaultSidebar","previous":{"title":"Core Concepts","permalink":"/docs/concepts"},"next":{"title":"Writing Hooks","permalink":"/docs/usage/writing-hooks"}}');var i=t(4848),s=t(8453);const r={sidebar_position:1,title:"Writing Components"},a=void 0,l={},c=[{value:"Configuring the component",id:"configuring-the-component",level:2},{value:"Component display name",id:"component-display-name",level:3},{value:"Component properties",id:"component-properties",level:3},{value:"Adding stages",id:"adding-stages",level:2},{value:"Custom stages",id:"custom-stages",level:3},{value:"Render stage",id:"render-stage",level:3},{value:"Registering stage functions",id:"registering-stage-functions",level:2},{value:"Manually registering stages",id:"manually-registering-stages",level:3},{value:"Registering the runtime implementation",id:"registering-the-runtime-implementation",level:4},{value:"Registering the typing information",id:"registering-the-typing-information",level:4},{value:"Automatically registering stages",id:"automatically-registering-stages",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["All our guides are written in TypeScript, as ",(0,i.jsx)(n.code,{children:"ModularComponent"})," was built from the ground up with TypeScript in mind.\nHowever, it is perfectly possible to take advantage of ",(0,i.jsx)(n.code,{children:"ModularComponent"})," with standard JavaScript."]})}),"\n",(0,i.jsx)(n.h2,{id:"configuring-the-component",children:"Configuring the component"}),"\n",(0,i.jsx)(n.p,{children:"At its simplest, a component is created by calling the factory:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\n\nexport const MyComponent = ModularComponent()\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is enough to get a valid, instantiable component. However, this component will do nothing: it does not handle\nany state, and renders ",(0,i.jsx)(n.code,{children:"null"})," by default."]}),"\n",(0,i.jsx)(n.h3,{id:"component-display-name",children:"Component display name"}),"\n",(0,i.jsxs)(n.p,{children:["One caveat of working with ",(0,i.jsx)(n.code,{children:"ModularComponent"})," is that React cannot infer its display name from the variable it is assigned to,\nbecause the actual component is created inside the factory. This can make debugging trickier, as stack traces and React Devtools\nwill show all components as anonymous components."]}),"\n",(0,i.jsx)(n.p,{children:"You can get around this limitation by manually providing an (optional) display name at component creation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\n\nexport const MyComponent = ModularComponent('MyComponent')\n"})}),"\n",(0,i.jsx)(n.p,{children:"It is a good practice to keep the debug name and the variable name in sync."}),"\n",(0,i.jsx)(n.h3,{id:"component-properties",children:"Component properties"}),"\n",(0,i.jsxs)(n.p,{children:["When using TypeScript, you can pass a generic type parameter to the ",(0,i.jsx)(n.code,{children:"ModularComponent"})," call to set the component's props:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\n\nexport const MyComponent = ModularComponent<{\n  isActive: boolean\n  label: string\n}>()\n"})}),"\n",(0,i.jsx)(n.p,{children:"The props typing will be passed along in each stage, and will also be used for the final typing of the component itself, so\nthat TypeScript knows about them when instantiating it."}),"\n",(0,i.jsx)(n.h2,{id:"adding-stages",children:"Adding stages"}),"\n",(0,i.jsxs)(n.p,{children:["Now that our component is created, we can ",(0,i.jsx)(n.strong,{children:"add stages"})," to it to extend its capabilities. The result of the factory is a usable React ",(0,i.jsx)(n.code,{children:"FunctionComponent"}),",\naugmented with custom factory methods. To add a stage to our component, we can use the ",(0,i.jsx)(n.code,{children:".with()"})," method."]}),"\n",(0,i.jsxs)(n.p,{children:["Note that ",(0,i.jsx)(n.strong,{children:"component factories"})," are immutable. Because of this, you need to chain the stage calls in the same\nassignment as your component creation. You ",(0,i.jsx)(n.em,{children:"cannot call them as side-effects"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"// \u26a0\ufe0f This will not work - `with(stage)` call returns a modified \n//    component but does not touch the original one\nconst MyComponent = ModularComponent()\n\nMyComponent.with(stage())\n\n// \u2705 Do this instead - save the result of the `with(stage)` call\n//    as your component\nconst MyComponent = ModularComponent()\n  .with(stage())\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This will come in very handy in the next chapters about ",(0,i.jsx)(n.a,{href:"/docs/usage/reusing-components",children:"extending and reusing components"}),", as well as for\n",(0,i.jsx)(n.a,{href:"/docs/usage/testing-components",children:"testing components"})]}),"\n",(0,i.jsx)(n.h3,{id:"custom-stages",children:"Custom stages"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:".with()"})," method accepts a standard argument, a function returning an object comprised of two fields:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"field"}),": the name of the argument that will get added to the argument map"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"provide"}),": a hook that receives the current argument map and returns the value to set on the stage field"]}),"\n"]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["While it's possible to use those objects directly when calling ",(0,i.jsx)(n.code,{children:".with()"}),", for readability and ease of writing we\nrecommend ",(0,i.jsxs)(n.a,{href:"/docs/usage/writing-custom-stages",children:["creating ",(0,i.jsx)(n.strong,{children:"custom stage functions"})]})," that take relevant parameters and abstract away the stage logic."]}),(0,i.jsxs)(n.p,{children:["All our ",(0,i.jsx)(n.a,{href:"/docs/extensions/official/",children:"official extensions"})," are actually this kind of functions."]})]}),"\n",(0,i.jsxs)(n.p,{children:["When calling ",(0,i.jsx)(n.code,{children:".with()"}),", each stage will add or modify\na field on the shared ",(0,i.jsx)(n.strong,{children:"argument map"}),", consolidating data that can be consumed by further stages."]}),"\n",(0,i.jsxs)(n.p,{children:["The order of stages is therefore important: only data from stages appearing ",(0,i.jsx)(n.em,{children:"higher in the list"})," will be available in\nany given stage."]}),"\n",(0,i.jsx)(n.p,{children:"Generic stages (handling default props, injecting localization data...) should come first in the pipeline. If needed,\nwe can then add a lifecycle stage handling the component's logic. Our component could look something like that:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\nimport { useDocumentTitle } from './custom-hooks'\n\nimport { lifecycle } from '@modular-component/with-lifecycle'\nimport { locale } from './custom-stages/with-locale'\nimport { globalStore } from './custom-stages/with-global-store'\n\nconst MyComponent = ModularComponent()\n  .with(globalStore())\n  .with(locale('localization.key.for.my.component'))\n  .with(lifecycle(({ locale, store }) => {\n    useDocumentTitle(locale('title'))\n    \n    const someStoreValue = store.useState((store) => store.some.value)\n    const [someInternalValue] = useState('value')\n    \n    return { someStoreValue, someInternalValue }\n  }))\n"})}),"\n",(0,i.jsx)(n.h3,{id:"render-stage",children:"Render stage"}),"\n",(0,i.jsxs)(n.p,{children:["Finally, we can close our component by adding a ",(0,i.jsx)(n.code,{children:"render"})," stage. Stages setting the ",(0,i.jsx)(n.code,{children:"render"})," field are special\nbecause the factory will look for it internally. As such, any stage ",(0,i.jsx)(n.em,{children:"downstream"})," of a ",(0,i.jsx)(n.code,{children:"render"})," stage will be ignored\nwhen rendering as a component."]}),"\n",(0,i.jsx)(n.p,{children:"Render stages need to return a valid React node, as their return will be used as the return value of the complete component.\nThis is enforced internally at the TypeScript level."}),"\n",(0,i.jsx)(n.p,{children:"Building on top of our previous example, this is what our component could look like:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\nimport { useDocumentTitle } from './custom-hooks'\n\nimport { render } from '@modular-component/core'\nimport { lifecycle } from '@modular-component/with-lifecycle'\nimport { locale } from './custom-stages/with-locale'\nimport { globalStore } from './custom-stages/with-global-store'\n\nconst MyComponent = ModularComponent()\n  .with(globalStore())\n  .with(locale('localization.key.for.my.component'))\n  .with(lifecycle(({ locale, store }) => {\n    useDocumentTitle(locale('title'))\n    \n    const someStoreValue = store.useState((store) => store.some.value)\n    const [someInternalValue] = useState('value')\n    \n    return { someStoreValue, someInternalValue }\n  }))\n  .with(render(({ locale, lifecycle }) => (\n    <>\n      <h1>{locale('title')}</h1>\n      <p>{locale('content')}</p>\n      <p>Value from store: {lifecycle.someStoreValue}</p>\n      <p>Value from state: {lifecycle.someInternalValue}</p>\n    </>\n  )))\n"})}),"\n",(0,i.jsx)(n.h2,{id:"registering-stage-functions",children:"Registering stage functions"}),"\n",(0,i.jsxs)(n.p,{children:["Stage functions can either be passed to the ",(0,i.jsx)(n.code,{children:".with()"})," function, or registered into the ",(0,i.jsx)(n.code,{children:"ModularComponent"}),"\nfactory for easier use."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ModularComponent"})," function has a static ",(0,i.jsx)(n.code,{children:"register"})," property that takes a record of stage functions and\ncreates new ",(0,i.jsx)(n.code,{children:"with<Stage>"})," functions assigned to the returned element of ",(0,i.jsx)(n.code,{children:"ModularComponent()"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"manually-registering-stages",children:"Manually registering stages"}),"\n",(0,i.jsx)(n.h4,{id:"registering-the-runtime-implementation",children:"Registering the runtime implementation"}),"\n",(0,i.jsxs)(n.p,{children:["You can register stages by calling the ",(0,i.jsx)(n.code,{children:"ModularComponent.register()"})," function.\nCalling ",(0,i.jsx)(n.code,{children:"register()"})," multiple times does not replace the registered stages, instead it\nmerges them."]}),"\n",(0,i.jsx)(n.p,{children:"You can use it to register stage functions exported by extensions, or to register\nyour own custom stage functions:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import { ModularComponent, render } from '@modular-component/core'\nimport { lifecycle } from '@modular-component/with-lifecycle'\nimport { locale } from './custom-stages/with-locale'\nimport { globalStore } from './custom-stages/with-global-store'\n\nModularComponent.register({\n  render,\n  lifecycle,\n  locale,\n  globalStore\n})\n"})}),"\n",(0,i.jsx)(n.h4,{id:"registering-the-typing-information",children:"Registering the typing information"}),"\n",(0,i.jsxs)(n.p,{children:["If you use TypeScript, you can tell the TypeScript compiler about the custom stages\nby extending the ",(0,i.jsx)(n.code,{children:"ModularComponentStages"})," interface exported by ",(0,i.jsx)(n.code,{children:"@modular-component/stages"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Extensions following our ",(0,i.jsx)(n.a,{href:"/docs/extensions/writing-extensions",children:"extensions best practices"})," will expose a ",(0,i.jsx)(n.code,{children:"With<Stage>"})," generic type that you can use for that purpose.\nSee ",(0,i.jsx)(n.a,{href:"/docs/usage/writing-custom-stages",children:"Writing Custom Stages"})," to learn how to write this type for\nyour custom stages."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import type { ModularContext, WithRender } from '@modular-component/core'\nimport type { WithLifecycle } from '@modular-component/with-lifecycle'\nimport type { WithLocale } from './custom-stages/with-locale'\nimport type { WithGlobalStore } from './custom-stages/with-global-store'\n\n// Extend @modular-component/stages by re-declaring it\ndeclare module '@modular-component/stages' {\n  export interface ModularComponentStages<Context extends ModularContext> {\n    withRender: WithRender<Context>\n    withLifecycle: WithLifecycle<Context>\n    withLocale: WithLocale<Context>\n    withGlobalStore: WithGlobalStore<Context>\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"automatically-registering-stages",children:"Automatically registering stages"}),"\n",(0,i.jsxs)(n.p,{children:["For stages exposed by extensions following our ",(0,i.jsx)(n.a,{href:"/docs/extensions/writing-extensions",children:"extensions best practices"}),", it's\npossible to automatically register the custom stage functions by importing a specific ",(0,i.jsx)(n.code,{children:"/register"})," subpath:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",children:"import '@modular-component/core/register'\nimport '@modular-component/with-lifecycle/register'\n"})}),"\n",(0,i.jsx)(n.p,{children:"Those imports will take care of both the runtime and TypeScript configuration."})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);
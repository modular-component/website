"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3976],{2053:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"intro","title":"ModularComponent","description":"\ud83c\udf5e.with(\ud83c\udf45).with(\ud83e\uddc0) = \ud83e\udd6a","source":"@site/docs/intro.md","sourceDirName":".","slug":"/intro","permalink":"/docs/intro","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"defaultSidebar","next":{"title":"Core Concepts","permalink":"/docs/concepts"}}');var s=t(4848),a=t(8453);const i={sidebar_position:1},l="ModularComponent",r={},c=[{value:"What are Modular Components",id:"what-are-modular-components",level:2},{value:"Installation",id:"installation",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"The factory pipeline",id:"the-factory-pipeline",level:3},{value:"Pipeline stages",id:"pipeline-stages",level:4},{value:"Adding stages",id:"adding-stages",level:4},{value:"Generating hooks",id:"generating-hooks",level:3},{value:"Other methods",id:"other-methods",level:3},{value:"Isolating a stage",id:"isolating-a-stage",level:4},{value:"Setting the component&#39;s <code>displayName</code>",id:"setting-the-components-displayname",level:4}];function d(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"modularcomponent",children:"ModularComponent"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"\ud83c\udf5e.with(\ud83c\udf45).with(\ud83e\uddc0) = \ud83e\udd6a"})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Delightfully organized and deeply testable React Components"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"what-are-modular-components",children:"What are Modular Components"}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["Prefer the TL;DR? See ",(0,s.jsx)(n.a,{href:"/docs/concepts",children:"Core Concepts"}),"."]})}),"\n",(0,s.jsx)(n.p,{children:"Modular Components are React components built through a modular factory, allowing\nfunctionality to be added as the component is being built."}),"\n",(0,s.jsx)(n.p,{children:"The modular factory approach is built on top of React hooks, and offers out-of-the-box\ncomposition for building and stub injections for testing."}),"\n",(0,s.jsx)(n.p,{children:"It offers best-in-class DX through strong typing and easy separation of concerns, and is\ninfinitely extensible thanks to its built-in modular nature."}),"\n",(0,s.jsx)(n.p,{children:'You can think of it as "higher-order hooks", without the awkward chaining of methods\nthanks to the factory pattern.'}),"\n",(0,s.jsx)(n.h2,{id:"installation",children:"Installation"}),"\n",(0,s.jsxs)(n.p,{children:["At minimum, you will need the ",(0,s.jsx)(n.code,{children:"@modular-component/core"})," package to get started with ",(0,s.jsx)(n.code,{children:"ModularComponent"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"However, the core module alone does not bring any component capability - it needs plugins,\nor extensions, to start shining \u2728 !"}),"\n",(0,s.jsxs)(n.p,{children:["We provide a sensible set of default capabilities through the ",(0,s.jsx)(n.code,{children:"@modular-component/default"})," package.\nIt is highly recommended to install both for getting started."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sh",children:"npm install @modular-component/core @modular-component/default\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can then build your components using the ",(0,s.jsx)(n.code,{children:"ModularComponent"})," factory exported from ",(0,s.jsx)(n.code,{children:"@modular-component/core"}),",\nand the default set of stages exported from ",(0,s.jsx)(n.code,{children:"@modular-component/default"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\nimport { ModularComponent } from '@modular-component/core'\nimport * as Stage from '@modular-component/default'\n\nconst MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  .with(Stage.defaultProps({ someFlag: false }))\n  .with(Stage.lifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  }))\n  .with(Stage.render(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  )))\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, you can opt to register custom stage functions on the factory.\nThis is the recommended way of using ",(0,s.jsx)(n.code,{children:"ModularComponent"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Extensions offer a ",(0,s.jsx)(n.code,{children:"/register"})," entrypoint for that purpose:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\nimport { ModularComponent } from '@modular-component/core'\nimport '@modular-component/default/register'\n\nconst MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  .withDefaultProps({ someFlag: false })\n  .withLifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  })\n  .withRender(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  ))\n"})}),"\n",(0,s.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,s.jsx)(n.h3,{id:"the-factory-pipeline",children:"The factory pipeline"}),"\n",(0,s.jsx)(n.h4,{id:"pipeline-stages",children:"Pipeline stages"}),"\n",(0,s.jsxs)(n.p,{children:["The main concept behind the ",(0,s.jsx)(n.code,{children:"ModularComponent"})," approach is the factory pipeline."]}),"\n",(0,s.jsxs)(n.p,{children:["At its core, a ",(0,s.jsx)(n.code,{children:"ModularComponent"})," is a set of ordered ",(0,s.jsx)(n.strong,{children:"stages"}),", each of which populates\na specific ",(0,s.jsx)(n.strong,{children:"argument"})," in a shared object, which gets passed from stage to stage."]}),"\n",(0,s.jsxs)(n.p,{children:["The last stage (usually the ",(0,s.jsx)(n.strong,{children:"render"})," stage) has therefore access\nto data computed by every previous stage in the pipeline."]}),"\n",(0,s.jsx)(n.p,{children:"This for instance allows separating any stateful lifecycle computation in a dedicated\nstage, and keep the render stage for its main purpose: laying down the markup through JSX."}),"\n",(0,s.jsx)(n.p,{children:'Here is the "getting started" example, complete with comments explaining\nthe pipeline system:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\nimport '@modular-component/default/register'\n\nconst MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  // .withDefaultProps() modifies the `props` argument to mark\n  // provided props as NonNullable. Here, `someFlag` will be\n  // a `boolean` for all downstream stages, instead of `boolean | undefined`\n  // as it originally was\n  .withDefaultProps({ someFlag: false })\n  // .withLifecycle() receives the modified props from .withDefaultProps()\n  // It then uses React hooks to construct our component's internal state\n  .withLifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  })\n  // Finally, .withRender() receives both the up-to-date props and the new\n  // lifecycle argument generated by the .withLifecycle() stage\n  .withRender(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  ))\n"})}),"\n",(0,s.jsx)(n.h4,{id:"adding-stages",children:"Adding stages"}),"\n",(0,s.jsxs)(n.p,{children:["You can keep on chaining ",(0,s.jsx)(n.code,{children:".with/.with<Stage>"})," calls as much as you want to add more stages. However, a given field can only be set once:\ncalling ",(0,s.jsx)(n.code,{children:".with/.with<Stage>"})," again with a different payload for the same field will replace the initial stage set for that field."]}),"\n",(0,s.jsxs)(n.p,{children:["When using TypeScript, the compiler will tell you if a subsequent call to ",(0,s.jsx)(n.code,{children:".with/.with<Stage>"})," with an existing field causes\na conflict with the previous value, to ensure coherence between stages."]}),"\n",(0,s.jsx)(n.admonition,{title:"TypeScript: Forcing a new value on a field",type:"info",children:(0,s.jsxs)(n.p,{children:["If you are using TypeScript and want to override a field completely without backwards compatibility with its previous\nvalue (for instance if you know you will be editing all stages depending on the field too), you can replace ",(0,s.jsx)(n.code,{children:".with/.with<Stage>"}),"\nwith ",(0,s.jsx)(n.code,{children:".force/.force<Stage>"}),", which does the same internally but bypasses the type checking."]})}),"\n",(0,s.jsx)(n.h3,{id:"generating-hooks",children:"Generating hooks"}),"\n",(0,s.jsxs)(n.p,{children:["By default, if a ",(0,s.jsx)(n.strong,{children:"render"})," stage is not provided in your pipeline, ",(0,s.jsx)(n.code,{children:"ModularComponent"})," will inject one on your behalf\nthat returns ",(0,s.jsx)(n.code,{children:"null"}),", so that your component stays renderable."]}),"\n",(0,s.jsxs)(n.p,{children:["But you can also opt to skip the render step entirely, turning your ",(0,s.jsx)(n.code,{children:"ModularComponent"})," into a hook."]}),"\n",(0,s.jsxs)(n.p,{children:["Simply append ",(0,s.jsx)(n.code,{children:"use()"})," at the end of your chain to enable this feature:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useState, useCallback } from 'react'\nimport { ModularComponent } from '@modular-component/core'\n\nconst useModularHook = ModularComponent()\n  .withLifecycle(() => {\n    const [enabled, setEnabled] = useState(false)\n    const toggleOn = useCallback(() => setEnabled(true), [])\n    const toggleOff = useCallback(() => setEnabled(false), [])\n    return { enabled, toggleOn, toggleOff }\n  })\n  .use()\n\n// ...\nconst { lifecycle } = useModularHook()\n\nlifecycle.toggleOn()\nlifecycle.enabled\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You can also pass the name of an argument field to the ",(0,s.jsx)(n.code,{children:"use()"})," method to isolate this specific stage.\nStages downstream to the stage generating the argument will be skipped, and the return value will be\nscoped to the selected field:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"import { useState, useCallback } from 'react'\nimport { ModularComponent } from '@modular-component/core'\n\nconst useIsolatedStage = ModularComponent()\n  .withLifecycle(() => {\n    const [enabled, setEnabled] = useState(false)\n    const toggleOn = useCallback(() => setEnabled(true), [])\n    const toggleOff = useCallback(() => setEnabled(false), [])\n    return { enabled, toggleOn, toggleOff }\n  })\n  .use('lifecycle')\n\n// ...\nconst { toggleOn, toggleOff, enabled } = useIsolatedStage()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"other-methods",children:"Other methods"}),"\n",(0,s.jsx)(n.h4,{id:"isolating-a-stage",children:"Isolating a stage"}),"\n",(0,s.jsxs)(n.p,{children:["For testing purposes, you might want to extract a stage function to be able to unit-test it in isolation. You can\nuse the ",(0,s.jsx)(n.code,{children:"stage()"})," method to achieve just that."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"stage()"})," takes things a step further than ",(0,s.jsx)(n.code,{children:"use()"}),", and should really only be used for testing purposes. It always takes\na field name to isolate, and returns a hook that takes the arguments map as parameter rather than the component props."]}),"\n",(0,s.jsxs)(n.p,{children:["When using ",(0,s.jsx)(n.code,{children:"stage()"}),", you are responsible for providing the relevant arguments expected by your stage function to work.\nIts only use-case is for testing purposes where you want to finely control each input and check the output."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["When calling ",(0,s.jsx)(n.code,{children:"stage('render')"}),", ",(0,s.jsx)(n.code,{children:"stage"})," will return a function component instead of a hook.\nIn fact, calling ",(0,s.jsx)(n.code,{children:"stage(field)"})," on any field returning a React node will create a function component\ninstead of a hook."]})}),"\n",(0,s.jsxs)(n.h4,{id:"setting-the-components-displayname",children:["Setting the component's ",(0,s.jsx)(n.code,{children:"displayName"})]}),"\n",(0,s.jsx)(n.p,{children:"Since the actual component function is created inside the factory, React cannot infer its display name from your\nvariable name. If you want to set a display name for debugging purposes, you have several ways:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Simply set the ",(0,s.jsx)(n.code,{children:"displayName"})," property on your generated component, like any other React component:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const MyComponent = ModularComponent()\n  .with(...)\n\nMyComponent.displayName = 'MyComponent'\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Pass your display name as first and only parameter to the initial ",(0,s.jsx)(n.code,{children:"ModularComponent"})," call:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const MyComponent = ModularComponent('MyComponent')\n  .with(...)\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Call ",(0,s.jsx)(n.code,{children:"withDisplayName"})," somewhere in your pipeline:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"const MyComponent = ModularComponent()\n  .withDisplayName('MyComponent')\n  .with(...)\n"})}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>l});var o=t(6540);const s={},a=o.createContext(s);function i(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);
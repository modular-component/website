"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[83],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),h=i,m=d["".concat(s,".").concat(h)]||d[h]||u[h]||o;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2873:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={slug:"using-internationalization",title:"Using an i18n provider",authors:"jvdsande",date:new Date("2022-10-22T00:00:00.000Z"),tags:["i18n"]},r=void 0,l={permalink:"/case-studies/using-internationalization",editUrl:"https://github.com/modular-component/website/case-studies/using-internationalization.md",source:"@site/case-studies/using-internationalization.md",title:"Using an i18n provider",description:"In this case study, we look at injecting a component localization data using i18next",date:"2022-10-22T00:00:00.000Z",formattedDate:"October 22, 2022",tags:[{label:"i18n",permalink:"/case-studies/tags/i-18-n"}],readingTime:4.415,hasTruncateMarker:!0,authors:[{name:"J\xe9r\xe9mie van der Sande",title:"Maintainer of ModularComponent",url:"https://github.com/jvdsande",imageURL:"https://github.com/jvdsande.png",key:"jvdsande"}],frontMatter:{slug:"using-internationalization",title:"Using an i18n provider",authors:"jvdsande",date:"2022-10-22T00:00:00.000Z",tags:["i18n"]},prevItem:{title:"Using an application global store",permalink:"/case-studies/using-global-store"}},s={authorsImageUrls:[void 0]},c=[{value:"<code>i18next</code>&#39;s <code>useTranslation</code> hook",id:"i18nexts-usetranslation-hook",level:2},{value:"Injecting the <code>t</code> function and other values",id:"injecting-the-t-function-and-other-values",level:2},{value:"Embracing component prefixes",id:"embracing-component-prefixes",level:2},{value:"Switching the localization data of an existing component",id:"switching-the-localization-data-of-an-existing-component",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c};function u(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"In this case study, we look at injecting a component localization data using ",(0,i.kt)("a",{parentName:"p",href:"https://www.i18next.com/"},(0,i.kt)("inlineCode",{parentName:"a"},"i18next")),"\nand TypeScript to build a custom modular stage."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"i18next")," is a well known library for handling your application's internationalization needs. At it simplest, you feed\nit with a map of key/value pairs for each language you want to support, and it provides you with a ",(0,i.kt)("inlineCode",{parentName:"p"},"t(key: string)")," function\nretrieving the correct value based on the currently configured language and the passed key."),(0,i.kt)("p",null,"When using TypeScript, you can further configure it with the list of valid keys, to get both type safety and autocompletion."),(0,i.kt)("p",null,"Using prefixes, you can scope your keys, and ",(0,i.kt)("inlineCode",{parentName:"p"},"i18next")," provides a ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," function generator taking a prefix as parameter\nand allowing accessing prefixed keys by the rest of their identifier only: for instance, ",(0,i.kt)("inlineCode",{parentName:"p"},"my.component.title")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"my.component.subtitle"),"\ncan be accessed through ",(0,i.kt)("inlineCode",{parentName:"p"},"t('title')")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t('subtitle')")," when ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," is generated with the ",(0,i.kt)("inlineCode",{parentName:"p"},"my.component")," prefix."),(0,i.kt)("h2",{id:"i18nexts-usetranslation-hook"},(0,i.kt)("inlineCode",{parentName:"h2"},"i18next"),"'s ",(0,i.kt)("inlineCode",{parentName:"h2"},"useTranslation")," hook"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"i18next")," also comes with a powerful React integration, through which you can retrieve your ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," functions from a hook\nsubscribed to locale changes. Thanks to this hook integration, it becomes fairly easy to integrate as a modular stage."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"useTranslation")," hook returns three variables: a configured ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," function, the raw ",(0,i.kt)("inlineCode",{parentName:"p"},"i18n")," object, and a ",(0,i.kt)("inlineCode",{parentName:"p"},"ready")," boolean\nused when dynamically loading translations."),(0,i.kt)("h2",{id:"injecting-the-t-function-and-other-values"},"Injecting the ",(0,i.kt)("inlineCode",{parentName:"h2"},"t")," function and other values"),(0,i.kt)("p",null,"Rather than importing ",(0,i.kt)("inlineCode",{parentName:"p"},"useTranslation")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"i18next-react")," everywhere localization is needed, we can take advantage of\n",(0,i.kt)("inlineCode",{parentName:"p"},"ModularComponent")," injection system. In this case study, we will focus on the returned ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," function, but you could create\na different stage function if you want to keep access to the ",(0,i.kt)("inlineCode",{parentName:"p"},"i18n")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"ready")," values."),(0,i.kt)("p",null,"For our case, here is how we would create the custom stage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { TFunction } from 'i18next'\nimport { useTranslation } from 'i18next-react'\n\nexport function locale(): ModularComponent<'locale', TFunction<'translation'>> {\n  return { \n    field: 'locale',\n    useStage: () => useTranslation('translation').t,\n  }\n}\n")),(0,i.kt)("p",null,"This simple stage simply calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"useTranslation")," hook with the default namespace, and returns the ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," function. It then\nstores it in the ",(0,i.kt)("inlineCode",{parentName:"p"},"locale")," field in the arguments map."),(0,i.kt)("p",null,"This allows us to easily used localized strings in our other stages, such as the render stage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const AppTitle = ModularComponent()\n  .with(locale())\n  .with(render(({ locale }) => (\n    <>\n      <h1>{locale('components.app-title.title')}</h1>\n      <h2>{locale('components.app-title.subtitle')}</h2>\n    </>\n  )))\n")),(0,i.kt)("h2",{id:"embracing-component-prefixes"},"Embracing component prefixes"),(0,i.kt)("p",null,"In the previous component, we had to repeat part of the localized string selector twice. Using ",(0,i.kt)("inlineCode",{parentName:"p"},"useTranslation")," directly,\nwe could have gone around this by providing a ",(0,i.kt)("inlineCode",{parentName:"p"},"keyPrefix")," configuration. "),(0,i.kt)("p",null,"We can set up our stage to optionally take this prefix as parameter, allowing us to retrieve a scoped ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," function."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { TFunction, TFuncKey } from 'i18next'\nimport { useTranslation } from 'i18next-react'\n\nexport function locale<Key extends TFuncKey<'translation'> = never>(\n  key?: Key,\n): ModularStage<\n  'locale',\n  () => [Key] extends [never] \n    ? TFunction<'translation'> \n    : TFunction<'translation', Key>\n> {\n  return {\n    field: 'locale',\n    useStage: () => useTranslation('translation', { keyPrefix: key }).t,\n  }\n}\n")),(0,i.kt)("p",null,"With this, we can simplify our component implementation by moving the common prefix to the stage initialization:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const AppTitle = ModularComponent()\n  .with(locale('components.app-title'))\n  .with(render(({ locale }) => (\n    <>\n      <h1>{locale('title')}</h1>\n      <h2>{locale('subtitle')}</h2>\n    </>\n  )))\n")),(0,i.kt)("p",null,"It then becomes really easy to implement shared practices around the application, scoping locales to a component's path\nfor instance."),(0,i.kt)("h2",{id:"switching-the-localization-data-of-an-existing-component"},"Switching the localization data of an existing component"),(0,i.kt)("p",null,"Since it is possible to create new components by taking a previous component and replacing a stage, we can take\nan existing component and change the locale's prefix to alter the rendered text. For instance, we could have a sub-page\ntitle inherit the implementation of our main application title:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"const SubPageTitle = AppTitle.with(locale('components.sub-page-title'))\n")),(0,i.kt)("p",null,"However, using the current setup for our stage, TypeScript will actually let us replace the prefix by any other valid\ntranslation key, instead of limiting it to prefixes for which the same scoped keys exist. Here, we would like to\nrestrict this, so that switching the prefix is only possible if it does not break the render."),(0,i.kt)("p",null,"Most of the time, this is done automatically by TypeScript by comparing the result of the ",(0,i.kt)("inlineCode",{parentName:"p"},"useStage")," function for the\nprevious stage value and the newly passed value. However, in this case, the ",(0,i.kt)("inlineCode",{parentName:"p"},"TFunction")," type is not strict enough to\ncover our needs. But we can go around it by modifying slightly the type of the returned function when a key is set:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { TFunction, TFuncKey } from 'i18next'\nimport { useTranslation } from 'i18next-react'\n\nexport function locale<Key extends TFuncKey<'translation'> = never>(\n  key?: Key,\n): ModularStage<\n  'locale',\n  () => [Key] extends [never] ? TFunction<'translation'> :\n    // highlight-next-line\n    | TFunction<'translation', Key>\n    // highlight-next-line\n    | ((key: TFuncKey<'translation', Key>) => string)\n> {\n  return {\n    field: 'locale',\n    useStage: () => useTranslation('translation', { keyPrefix: key }).t,\n  }\n}\n")),(0,i.kt)("p",null,"By adding this stricter restriction through a union type, we keep the original behavior, but only prefixes yielding compatible sub-selectors will be accepted when replacing a stage."),(0,i.kt)("h2",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"With this localization stage, we get a very easy way to integrate localized strings inside our components, with the full\ntype-safety offered by ",(0,i.kt)("inlineCode",{parentName:"p"},"i18next"),". By lifting the prefix definition at the factory level, we also make it easy to put\nbest practices in place for organizing our locales linked to our components."),(0,i.kt)("p",null,"You can also check our other case study about ",(0,i.kt)("a",{parentName:"p",href:"/case-studies/using-global-store"},"configuring golabl store access as a stage"),"."))}u.isMDXComponent=!0}}]);
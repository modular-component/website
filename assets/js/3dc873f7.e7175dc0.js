"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6936],{1440:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>m});const o=JSON.parse('{"id":"extensions/official/with-components","title":"@modular-component/with-components","description":"Provides a components() stage that fills the components argument with","source":"@site/docs/extensions/official/with-components.md","sourceDirName":"extensions/official","slug":"/extensions/official/with-components","permalink":"/docs/extensions/official/with-components","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/extensions/official/with-components.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"defaultSidebar","previous":{"title":"@modular-component/with-lifecycle","permalink":"/docs/extensions/official/with-lifecycle"},"next":{"title":"@modular-component/with-conditional-render","permalink":"/docs/extensions/official/with-conditional-render"}}');var s=t(4848),r=t(8453);const i={sidebar_position:4},a="@modular-component/with-components",c={},m=[{value:"Usage",id:"usage",level:2},{value:"Replacing sub-components",id:"replacing-sub-components",level:2},{value:"Stage registration",id:"stage-registration",level:2},{value:"Implementation",id:"implementation",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"modular-componentwith-components",children:"@modular-component/with-components"})}),"\n",(0,s.jsxs)(e.p,{children:["Provides a ",(0,s.jsx)(e.code,{children:"components()"})," stage that fills the ",(0,s.jsx)(e.code,{children:"components"})," argument with\na map of React components. Useful when running tests in an environment that\ndoes not allow module mocking: sub-components can be stubbed in tests by\nmocking the stage to replace their implementations."]}),"\n",(0,s.jsx)(e.h2,{id:"usage",children:"Usage"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Stage function imports"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:"import { ModularComponent, render } from '@modular-component/core'\nimport { components } from '@modular-component/with-components'\n\nimport { SomeComponent } from 'some-component'\n\nconst MyComponent = ModularComponent()\n  .with(components({ SomeComponent }))\n  .with(render(({ props, components }) => <components.SomeComponent />))\n"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Stage registration"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\nimport '@modular-component/core/register'\nimport '@modular-component/with-components/register'\n\nimport { SomeComponent } from 'some-component'\n\nconst MyComponent = ModularComponent()\n  .withComponents({ SomeComponent })\n  .withRender(({ props, components }) => <components.SomeComponent />)\n"})}),"\n",(0,s.jsx)(e.h2,{id:"replacing-sub-components",children:"Replacing sub-components"}),"\n",(0,s.jsxs)(e.p,{children:["Replacing sub-components can be done either by updating or mocking the stage.\nIt allows creating a clone of the component with a different set of sub-components,\neither for tests or for content.\nFor instance, one could imagine a ",(0,s.jsx)(e.code,{children:"Layout"})," base component taking advantage of this functionality:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:"import React from 'react'\n\nconst PageLayout = ModularComponent()\n  .withComponents({\n    Title: React.Fragment,\n    Subtitle: React.Fragment,\n    Content: React.Fragment,\n    Footer: React.Fragment,\n  })\n  .withRender(({ components }) => {\n    // Build a layout using <components.Title />, <components.Subtitle />...\n  })\n\nconst PageOne = PageLayout.withComponents({\n  Title: () => <>First page</>,\n  Subtitle: () => <>I have a subtitle but no footer</>,\n  Content: () => <>First page content</>,\n  Footer: React.Fragment,\n})\n\nconst PageTwo = PageLayout.withComponents({\n  Title: () => <>Second page</>,\n  Subtitle: React.Fragment,\n  Content: () => <>Second page content</>,\n  Footer: () => <>I have a footer but no subtitle</>,\n})\n"})}),"\n",(0,s.jsx)(e.h2,{id:"stage-registration",children:"Stage registration"}),"\n",(0,s.jsxs)(e.p,{children:["You can either automatically register the stage on ",(0,s.jsx)(e.code,{children:"withComponents"})," by importing ",(0,s.jsx)(e.code,{children:"@modular-component/with-components/register"}),",\nor handle the registration manually thanks to the ",(0,s.jsx)(e.code,{children:"components"})," function and ",(0,s.jsx)(e.code,{children:"WithComponents"})," type exports."]}),"\n",(0,s.jsxs)(e.p,{children:["For instance, here is how you could register it on ",(0,s.jsx)(e.code,{children:"withSubComponents"})," instead:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ts",children:"import { ModularComponent, ModularContext } from '@modular-component/core'\nimport { components, WithComponents } from '@modular-component/with-components'\n\n// Register the stage on the factory\nModularComponent.register({ subComponents: components })\n\n// Extend the type definition\ndeclare module '@modular-component/stages' {\n  export interface ModularComponentStages<Context extends ModularContext> {\n    withSubComponents: WithComponents<Context>\n  }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"implementation",children:"Implementation"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"components()"})," is a simple stage adding the provided record as a ",(0,s.jsx)(e.code,{children:"components"})," argument. It has a restriction\non accepted values, to only accept a record of React components."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-tsx",children:"import { ComponentType } from 'react'\nimport {\n  addTo,\n  wrap,\n  ModularContext,\n  GetConstraintFor,\n  GetValueGetterFor,\n  StageParams,\n  StageReturn,\n} from '@modular-component/core/extend'\n\ntype Constraint<Context extends ModularContext> = GetConstraintFor<\n  Context,\n  'components',\n  Record<string, ComponentType<any>>\n>\n\nexport function components<\n  Context extends ModularContext,\n  Type extends Constraint<Context>,\n>(components: GetValueGetterFor<Context, 'components', Type>) {\n  return addTo<Context>().on('components').provide(wrap(components))\n}\n\nexport type WithComponents<\n  Context extends ModularContext\n> = <\n  Type extends Constraint<Context>,\n>(\n  ...args: StageParams<typeof components<Context, Type>>\n) => StageReturn<typeof components<Context, Type>>\n\n"})})]})}function l(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>i,x:()=>a});var o=t(6540);const s={},r=o.createContext(s);function i(n){const e=o.useContext(r);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:i(n.components),o.createElement(r.Provider,{value:e},n.children)}}}]);
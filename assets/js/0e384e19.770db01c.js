"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),p=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=a,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||r;return n?o.createElement(h,i(i({ref:t},c),{},{components:n})):o.createElement(h,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9881:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=n(7462),a=(n(7294),n(3905));const r={sidebar_position:1},i="ModularComponent",l={unversionedId:"intro",id:"intro",title:"ModularComponent",description:"\ud83c\udf5e.with(\ud83c\udf45).with(\ud83e\uddc0) = \ud83e\udd6a",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/docs/intro",draft:!1,editUrl:"https://github.com/modular-component/website/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Building the Factory",permalink:"/docs/usage/building-the-factory"}},s={},p=[{value:"What are Modular Components",id:"what-are-modular-components",level:2},{value:"Installation",id:"installation",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"The factory pipeline",id:"the-factory-pipeline",level:3},{value:"Pipeline stages",id:"pipeline-stages",level:4},{value:"Stages modes",id:"stages-modes",level:4},{value:"Other methods",id:"other-methods",level:3}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"modularcomponent"},"ModularComponent"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\ud83c\udf5e.with(\ud83c\udf45).with(\ud83e\uddc0) = \ud83e\udd6a")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Delightfully organized and deeply testable React Components")),(0,a.kt)("h2",{id:"what-are-modular-components"},"What are Modular Components"),(0,a.kt)("p",null,"Modular Components are React components built through a modular factory, allowing to\nadd functionality as needed as the component is built.\nThe modular factory approach is built on top of React hooks, and offers out-of-the-box\ncomposition for building and stub injections for testing."),(0,a.kt)("p",null,"It offers best-in-class DX through strong typing and easy separation of concern, and is\ninfinitely extensible thanks to its built-in modular nature.",(0,a.kt)("br",{parentName:"p"}),"\n",'You can think of it as "higher-order hooks", without the awkward chaining of methods\nthanks to the factory pattern.'),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"At it simplest, you will need the ",(0,a.kt)("inlineCode",{parentName:"p"},"@modular-component/core")," package to get started with ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent"),"."),(0,a.kt)("p",null,"However, the core module alone does not bring any component capability - it needs plugins,\nor extensions, to start shining \u2728 !"),(0,a.kt)("p",null,"We provide a sensible set of default capabilities through the ",(0,a.kt)("inlineCode",{parentName:"p"},"@modular-component/default")," package.\nIt is highly recommended to install both for getting started."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add @modular-component/core @modular-component/default\n")),(0,a.kt)("p",null,"You can then build your component factory by combining the ",(0,a.kt)("inlineCode",{parentName:"p"},"modularFactory")," export from\n",(0,a.kt)("inlineCode",{parentName:"p"},"@modular-component/core"),", and the default set of stages exported as ",(0,a.kt)("inlineCode",{parentName:"p"},"WithDefaultStages"),"\nfrom ",(0,a.kt)("inlineCode",{parentName:"p"},"@modular-component/default"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { modularFactory } from '@modular-component/core'\nimport { WithDefaultStages } from '@modular-component/default'\n\nconst ModularComponent = modularFactory.extend(WithDefaultStages).build()\n")),(0,a.kt)("p",null,"From there, you can instantiate new components with the ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," factory function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  .withDefaultProps({ someFlag: false })\n  .withLifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  })\n  .withRender(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  ))\n")),(0,a.kt)("h2",{id:"how-it-works"},"How it works"),(0,a.kt)("h3",{id:"the-factory-pipeline"},"The factory pipeline"),(0,a.kt)("h4",{id:"pipeline-stages"},"Pipeline stages"),(0,a.kt)("p",null,"The main concept behind the ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," approach is the factory pipeline."),(0,a.kt)("p",null,"At its core, a ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," is a set of ordered ",(0,a.kt)("strong",{parentName:"p"},"stages"),", each of which populates\na specific ",(0,a.kt)("strong",{parentName:"p"},"argument")," in a shared object, which gets passed from stage to stage."),(0,a.kt)("p",null,"The last stage (usually, but not necessarily, the ",(0,a.kt)("strong",{parentName:"p"},"render stage"),") has therefore access\nto data computed by every previous stage in the pipeline."),(0,a.kt)("p",null,"This allows for instance to separate any stateful lifecycle computation in a dedicated\nstage, and keep the render stage for its main purpose: laying down the markup through JSX."),(0,a.kt)("p",null,'Here is the "getting started" example, complete with comments explaining\nthe pipeline system:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ModularComponent } from '@modular-component/core'\n\nconst MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  // .withDefaultProps modifies the `props` argument to mark\n  // provided props as NonNullable. Here, `someFlag` will be\n  // a `boolean` for all further stages, instead of `boolean | undefined`\n  // as it originally was\n  .withDefaultProps({ someFlag: false })\n  // .withLifecycle receives the modified props from .withDefaultProps\n  // It then uses React hooks to construct our component's internal state\n  .withLifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  })\n  // Finally, .withRender receives both the up-to-date props and the new\n  // lifecycle argument generated by the .withLifecycle stage\n  .withRender(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  ))\n")),(0,a.kt)("h4",{id:"stages-modes"},"Stages modes"),(0,a.kt)("p",null,"Each stage can be called multiple time, but the way subsequent calls to the\nsame stage are handled depends on its ",(0,a.kt)("strong",{parentName:"p"},"mode"),"."),(0,a.kt)("p",null,"Stages can have one of two modes: ",(0,a.kt)("strong",{parentName:"p"},"single")," (default), or ",(0,a.kt)("strong",{parentName:"p"},"multiple"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"A ",(0,a.kt)("strong",{parentName:"p"},"single"),"-mode stage can only be inserted once in a pipeline. Further calls\nto the same stage function will replace the implementation of the stage but keep its\nposition in the pipeline."),(0,a.kt)("p",{parentName:"li"},"Because of this, it's important that the provided argument honors the contract\nset up by the very first call, otherwise it could break stages depending on it."),(0,a.kt)("p",{parentName:"li"},"When using TypeScript, this is enforced internally, and a subsequent call to an already\nadded stage will be narrowed to force honoring previous contracts.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"A ",(0,a.kt)("strong",{parentName:"p"},"multiple"),"-mode stage on the other hand can appear in various places in the pipeline."),(0,a.kt)("p",{parentName:"li"},"Further calls to the stage function will simply add new stages to the pipeline, modifying the\ngenerated value only for further stages down the pipeline."),(0,a.kt)("p",{parentName:"li"},"Since calls are never modified, further calls can completely change the value of the field\nwithout any impact on previous stages. For the same reason, the TypeScript definition is not\nrestricted in any way."))),(0,a.kt)("p",null,"The reason for the ",(0,a.kt)("strong",{parentName:"p"},"single")," mode being default is to help re-usability: for instance, you can\nextend an existing component by replacing its lifecycle but keeping the same render, or vice-versa."),(0,a.kt)("p",null,"This also makes ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent"),"s easy to test: stages can be tested in isolation from one another."),(0,a.kt)("h3",{id:"other-methods"},"Other methods"),(0,a.kt)("p",null,"Atop of the factory stages configured through extensions, ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent"),"s\nalso expose two more methods:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"asHook"),": extract the stages as a custom hook, returning the map of arguments.\nThis is used internally when calling the generated component, but can also be\nuseful in other situations like tests, or the need to generate a shared hook\nconsuming application context, such as a global store for which a stage exists."),(0,a.kt)("p",{parentName:"li"},"It optionally takes a string parameter allowing to extract a specific argument.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"atStage"),": rewinds a factory all the way up to a specific stage\n(in case of multiple-mode stages, the last occurrence is used), and return\na new ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," with the remaining stages.\nUseful for instance to test in isolation the first few stages of a component.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"mockStage"),": replace a stage with a mocked implementation, skipping its transform\nentirely. For some single stages, calling the stage itself could help with mocking,\nbut sometimes we don't want the transform to run at all, and mock the resulting value\ndirectly. ",(0,a.kt)("inlineCode",{parentName:"p"},"mockStage")," does just that. In case of multiple-mode stages, the\nlast occurrence is mocked.\nThe mock can either be a direct value, or a function returning the value. As\nwith stage functions, if the value to mock should be a function, then it needs\nto be wrapped in an anonymous function.\nThe accepted values for mocking are strongly typed to respect the contract\nset by the original stage."))),(0,a.kt)("p",null,"Combining those three methods can be very powerful in testing scenarios. For instance,\none can extract the lifecycle hook of a component by chaining them:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const useLifecycle = MyComponent.atStage('withLifecycle').asHook('lifecycle')\n")),(0,a.kt)("p",null,"Or one could mock the lifecycle entirely to test the render:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"const OnlyRender = MyComponent.mockStage('withLifecycle', { fromLifecycle: 'hello world' })\n")))}u.isMDXComponent=!0}}]);
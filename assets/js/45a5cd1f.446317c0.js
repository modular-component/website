"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[4e3],{7515:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"concepts","title":"Core Concepts","description":"This page condenses the mental model behind ModularComponent so you can skim the essentials","source":"@site/docs/concepts.md","sourceDirName":".","slug":"/concepts","permalink":"/docs/concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/concepts.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Core Concepts"},"sidebar":"tutorialSidebar","previous":{"title":"ModularComponent","permalink":"/docs/intro"},"next":{"title":"Writing Components","permalink":"/docs/usage/writing-components"}}');var i=t(4848),r=t(8453);const o={sidebar_position:2,title:"Core Concepts"},c="Core Concepts",l={},a=[{value:"Factory-first React components",id:"factory-first-react-components",level:2},{value:"The pipeline of stages",id:"the-pipeline-of-stages",level:2},{value:"Arguments map cheatsheet",id:"arguments-map-cheatsheet",level:3},{value:"Stage functions &amp; extensions",id:"stage-functions--extensions",level:2},{value:"Derived hooks",id:"derived-hooks",level:2},{value:"Testing strategy",id:"testing-strategy",level:2},{value:"Reuse &amp; composition patterns",id:"reuse--composition-patterns",level:2},{value:"Troubleshooting signals",id:"troubleshooting-signals",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"core-concepts",children:"Core Concepts"})}),"\n",(0,i.jsxs)(n.p,{children:["This page condenses the mental model behind ",(0,i.jsx)(n.code,{children:"ModularComponent"})," so you can skim the essentials\nor feed them to an LLM before asking for help. Each section links to the deeper dives in the\nrest of the docs."]}),"\n",(0,i.jsx)(n.h2,{id:"factory-first-react-components",children:"Factory-first React components"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["You never write the React component function directly. Instead, you call ",(0,i.jsx)(n.code,{children:"ModularComponent()"}),"\nto receive a factory that accumulates behavior via chained ",(0,i.jsx)(n.code,{children:".with*"})," calls."]}),"\n",(0,i.jsxs)(n.li,{children:["The factory returns an enhanced React component: it is a function component (or ",(0,i.jsx)(n.code,{children:"forwardRef"}),")\nAND it carries helper methods (",(0,i.jsx)(n.code,{children:"withDefaultProps"}),", ",(0,i.jsx)(n.code,{children:"withLifecycle"}),", etc.) so composition is declarative."]}),"\n",(0,i.jsx)(n.li,{children:"The factory call optionally takes a display name and generic props/ref types to seed TypeScript."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"the-pipeline-of-stages",children:"The pipeline of stages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Every ",(0,i.jsx)(n.code,{children:".with(stage())"})," call appends a ",(0,i.jsx)(n.strong,{children:"stage"})," to an ordered pipeline."]}),"\n",(0,i.jsxs)(n.li,{children:["Stages produce values that populate a shared ",(0,i.jsx)(n.strong,{children:"arguments map"}),"; each argument is keyed\n(e.g. ",(0,i.jsx)(n.code,{children:"props"}),", ",(0,i.jsx)(n.code,{children:"lifecycle"}),", ",(0,i.jsx)(n.code,{children:"render"}),"). Downstream stages receive whatever upstream stages already provided."]}),"\n",(0,i.jsxs)(n.li,{children:["A field can only be assigned once per pipeline. Use ",(0,i.jsx)(n.code,{children:".force*"})," if you intentionally want to replace a field\neven when TypeScript would flag incompatibilities."]}),"\n",(0,i.jsxs)(n.li,{children:["Stage order matters: put generic/context stages first, stateful logic next, rendering last. Once a ",(0,i.jsx)(n.code,{children:"render"}),"\nfield is populated, further stages are ignored for component rendering (but still available when you call ",(0,i.jsx)(n.code,{children:"use()"})," or ",(0,i.jsx)(n.code,{children:"stage()"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"arguments-map-cheatsheet",children:"Arguments map cheatsheet"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Argument"}),(0,i.jsx)(n.th,{children:"Source"}),(0,i.jsx)(n.th,{children:"Common contents"}),(0,i.jsx)(n.th,{children:"Consumers"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"props"})}),(0,i.jsx)(n.td,{children:"Factory generics"}),(0,i.jsx)(n.td,{children:"Final component props after defaults/guards"}),(0,i.jsx)(n.td,{children:"Every stage needing inputs from callers"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"ref"})}),(0,i.jsx)(n.td,{children:"Factory generics"}),(0,i.jsx)(n.td,{children:"Forwarded ref type/value"}),(0,i.jsx)(n.td,{children:"Render stage or custom lifecycle helpers"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{children:["Custom fields ",(0,i.jsx)("br",{})," (e.g. ",(0,i.jsx)(n.code,{children:"lifecycle"}),", ",(0,i.jsx)(n.code,{children:"store"}),", ",(0,i.jsx)(n.code,{children:"locale"}),")"]}),(0,i.jsx)(n.td,{children:"Any stage you add"}),(0,i.jsx)(n.td,{children:"Whatever the stage returns (hooks, data)"}),(0,i.jsx)(n.td,{children:"Subsequent stages and render"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:(0,i.jsx)(n.code,{children:"render"})}),(0,i.jsxs)(n.td,{children:[(0,i.jsx)(n.code,{children:"render()"})," stage"]}),(0,i.jsx)(n.td,{children:"A valid React node"}),(0,i.jsx)(n.td,{children:"Only the final React component"})]})]})]}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/docs/intro#how-it-works",children:"How it works"})," for the long-form explanation."]}),"\n",(0,i.jsx)(n.h2,{id:"stage-functions--extensions",children:"Stage functions & extensions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Bare ",(0,i.jsx)(n.code,{children:".with()"})," expects a function returning a low-level object ",(0,i.jsx)(n.code,{children:"{ field, provide }"}),".\nIn practice, you wrap that in ",(0,i.jsx)(n.strong,{children:"stage functions"})," such as ",(0,i.jsx)(n.code,{children:"lifecycle(params)"})," or ",(0,i.jsx)(n.code,{children:"defaultProps(values)"}),"\nso pipelines stay readable. See ",(0,i.jsx)(n.a,{href:"/docs/usage/writing-custom-stages",children:"Writing custom stages"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Extensions (e.g. ",(0,i.jsx)(n.code,{children:"@modular-component/default"}),") simply export curated stage functions. Import them directly or\ncall their ",(0,i.jsx)(n.code,{children:"/register"})," entrypoint to attach ",(0,i.jsx)(n.code,{children:"withX"})," helpers globally."]}),"\n",(0,i.jsxs)(n.li,{children:["Register stages for runtime behavior with ",(0,i.jsx)(n.code,{children:"ModularComponent.register({ stageName })"}),". For TypeScript, declare\nmodule augmentation so the compiler knows the helpers exist. See ",(0,i.jsx)(n.a,{href:"/docs/usage/writing-custom-stages",children:"Writing custom stages"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"derived-hooks",children:"Derived hooks"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Append ",(0,i.jsx)(n.code,{children:".use()"})," to convert your component into a hook. You still get the full arguments map, making it\neasy to expose lifecycle logic as a reusable hook."]}),"\n",(0,i.jsxs)(n.li,{children:["Pass ",(0,i.jsx)(n.code,{children:".use('field')"})," to extract only one argument; the pipeline stops at the first stage providing that argument,\nand returns the value directly."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:".stage('field')"})," is for testing: it returns a hook (or component when the field emits React nodes) that expects\nyou to pass the argument map manually. Perfect for unit tests that isolate a single stage without running the rest."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"testing-strategy",children:"Testing strategy"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Because every stage is a hook/function returning plain data, you can test them independently via ",(0,i.jsx)(n.code,{children:".stage()"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["For integration-style tests, instantiate the full component returned by the factory; default props and lifecycle\nlogic will run exactly as in production. See ",(0,i.jsx)(n.a,{href:"/docs/usage/testing-components",children:"Testing components"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"reuse--composition-patterns",children:"Reuse & composition patterns"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Factories are immutable: each ",(0,i.jsx)(n.code,{children:".with()"})," call returns a new component. Store that return value and re-export it."]}),"\n",(0,i.jsxs)(n.li,{children:["Build base components (or hooks) then extend them with more ",(0,i.jsx)(n.code,{children:".with()"})," calls to create variants. Since the pipeline\nis declarative, higher-level components can keep inheriting lower-level stages."]}),"\n",(0,i.jsx)(n.li,{children:"Share cross-cutting concerns (stores, localization, analytics) by bundling them into custom stage functions and\nreusing them across factories."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting-signals",children:"Troubleshooting signals"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Missing ",(0,i.jsx)(n.code,{children:"render"}),": the factory injects a noop render, so if nothing shows on screen verify that a ",(0,i.jsx)(n.code,{children:"render"})," stage exists."]}),"\n",(0,i.jsx)(n.li,{children:"Stage ordering bugs: if downstream stages cannot see values, confirm that the stage providing them appears earlier\nand that no conflicting field overwrote it."}),"\n",(0,i.jsxs)(n.li,{children:["TypeScript conflicts: when generics or constraints complain, revisit whether ",(0,i.jsx)(n.code,{children:".with"})," or ",(0,i.jsx)(n.code,{children:".force"})," is appropriate and\nensure module augmentation exposes any custom stage helpers."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5736],{5988:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"usage/writing-custom-stages","title":"Writing Custom Stages","description":"This guide describes how to write custom stage function providers, such","source":"@site/docs/usage/writing-custom-stages.md","sourceDirName":"usage","slug":"/usage/writing-custom-stages","permalink":"/docs/usage/writing-custom-stages","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/usage/writing-custom-stages.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Writing Custom Stages"},"sidebar":"tutorialSidebar","previous":{"title":"Writing Hooks","permalink":"/docs/usage/writing-hooks"},"next":{"title":"Reusing Components","permalink":"/docs/usage/reusing-components"}}');var o=t(4848),i=t(8453);const a={sidebar_position:3,title:"Writing Custom Stages"},s=void 0,d={},l=[{value:"Stage function shape",id:"stage-function-shape",level:2},{value:"The <code>addTo</code> helper",id:"the-addto-helper",level:2},{value:"Creating a stage function provider",id:"creating-a-stage-function-provider",level:2},{value:"Providing parameters",id:"providing-parameters",level:3},{value:"Making the field dynamic",id:"making-the-field-dynamic",level:3},{value:"Exposing arguments to the consumer",id:"exposing-arguments-to-the-consumer",level:3},{value:"<code>GetArgsFor</code>",id:"getargsfor",level:4},{value:"<code>GetValueGetterFor</code> and <code>wrap</code> (recommended)",id:"getvaluegetterfor-and-wrap-recommended",level:4},{value:"Constraining the return type",id:"constraining-the-return-type",level:3},{value:"Providing a type for registering the stage",id:"providing-a-type-for-registering-the-stage",level:2},{value:"Registering the stage",id:"registering-the-stage",level:2},{value:"Registering the runtime implementation",id:"registering-the-runtime-implementation",level:3},{value:"Registering the typing information",id:"registering-the-typing-information",level:3},{value:"Putting it together",id:"putting-it-together",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["This guide describes how to write custom stage function providers, such\nas those provided by our ",(0,o.jsx)(n.a,{href:"/docs/extensions/official/",children:"official extensions"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Use your own custom stages to personalize your ",(0,o.jsx)(n.code,{children:"ModularComponent"})," experience and tailor\nit to your application (inject services, access a global store, use your internationalization solution...)."]}),"\n",(0,o.jsx)(n.h2,{id:"stage-function-shape",children:"Stage function shape"}),"\n",(0,o.jsxs)(n.p,{children:["A stage function is a function that can be passed to the ",(0,o.jsx)(n.code,{children:".with()"})," method\nof a ",(0,o.jsx)(n.code,{children:"ModularComponent"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"It needs the following signature:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"(ctx?: Context): {\n  field: Field,\n  provide: (args: GetArgsFor<Context, Field>) => Type\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The optional ",(0,o.jsx)(n.code,{children:"ctx"})," parameter is there so that TypeScript\ncan infer its value from the ",(0,o.jsx)(n.code,{children:"ModularComponent"})," to which\nthe function is passed. This is the key to being able to\ninfer the arguments received by the ",(0,o.jsx)(n.code,{children:"provide"})," function, and\ntherefore its own return type."]}),"\n",(0,o.jsxs)(n.p,{children:["It is marked optional because ",(0,o.jsx)(n.em,{children:"the factory will never actually set that\nparameter"}),", it's only there to pass down the arguments type information."]}),"\n",(0,o.jsxs)(n.p,{children:["The returned object describes how the stage will modify the arguments map:\n",(0,o.jsx)(n.code,{children:"field"})," is the property that will be added or modified on the arguments map,\nwhile ",(0,o.jsx)(n.code,{children:"provide"})," is a function that takes the current arguments map up to that stage,\nand returns the value to store in ",(0,o.jsx)(n.code,{children:"field"}),"."]}),"\n",(0,o.jsxs)(n.h2,{id:"the-addto-helper",children:["The ",(0,o.jsx)(n.code,{children:"addTo"})," helper"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"@modular-component/core/extend"})," subpath exports an ",(0,o.jsx)(n.code,{children:"addTo"})," function aimed\nat helping build stage functions."]}),"\n",(0,o.jsxs)(n.p,{children:["It works as a chain of three functions: ",(0,o.jsx)(n.code,{children:"addTo"})," returns an ",(0,o.jsx)(n.code,{children:"on"})," function to specify the field (and infer its type from the provided value),\nwhich in turn returns a ",(0,o.jsx)(n.code,{children:"provide"})," function to set the arguments transformer, pre-configured to receive the correct arguments\nfor the field, and infers its return type."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"addTo"})," function takes the current context as a generic TypeScript type parameter."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const stage = addTo<Context>()\n    .on('field')\n    .provide((args) => /* compute field value from args */)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"creating-a-stage-function-provider",children:"Creating a stage function provider"}),"\n",(0,o.jsxs)(n.p,{children:["In order to automatically infer the ",(0,o.jsx)(n.code,{children:"Context"})," type and allow providing custom arguments usable inside the ",(0,o.jsx)(n.code,{children:"use"})," transformer function,\nwe will wrap our ",(0,o.jsx)(n.code,{children:"stage"})," definition inside a provider function."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { ModularContext, addTo } from '@modular-component/core/extend'\n\nfunction stage<Context extends ModularContext>(...params: any[]) {\n  return addTo<Context>()\n    .on('field')\n    .provide((args) => /* compute field value from args and params */)\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"providing-parameters",children:"Providing parameters"}),"\n",(0,o.jsx)(n.p,{children:"You are free to provide as many parameters as required for your stage to make sense. For instance, a localization stage\ncan receive a key prefix to use in a translation hook, providing a locale getter scoped to that prefix."}),"\n",(0,o.jsx)(n.p,{children:"We can leverage our provider function to infer and narrow the type of parameters through generic type parameters:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { ModularContext, addTo } from '@modular-component/core/extend'\nimport { AvailablePrefixes, GetterFromPrefix, useTranslation } from './locale-system'\n\nfunction locale<\n  Context extends ModularContext,\n  KeyPrefix extends AvailablePrefixes\n>(keyPrefix: KeyPrefix) {\n  return addTo<Context>()\n    .on('locale')\n    .provide((args): GetterFromPrefix<KeyPrefix> => useTranslation(keyPrefix)) \n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"making-the-field-dynamic",children:"Making the field dynamic"}),"\n",(0,o.jsx)(n.p,{children:"Since the field is provided inside our provider function, it also becomes possible to infer it from a parameter. This\nallows creating dynamic stage providers that let the consumer choose the field to populate:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { ModularContext, addTo } from '@modular-component/core/extend'\n\nfunction stage<\n  Context extends ModularContext,\n  Field extends string,\n  Value\n>(field: Field, value: Value) {\n  return addTo<Context>()\n    .on(field)\n    .provide(() => value) \n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"exposing-arguments-to-the-consumer",children:"Exposing arguments to the consumer"}),"\n",(0,o.jsxs)(n.p,{children:["It can be useful to let the consumer access the arguments provided by upstream stages to compute their own value.\nThis is the case for the ",(0,o.jsx)(n.a,{href:"/docs/usage/writing-components#render-stage",children:"render stage"})," or the ",(0,o.jsx)(n.a,{href:"/docs/extensions/official/with-lifecycle",children:"lifecycle extension"}),"\nfor instance."]}),"\n",(0,o.jsxs)(n.p,{children:["The arguments are provided by the ",(0,o.jsx)(n.code,{children:"provide"})," function, but can be inferred from the ",(0,o.jsx)(n.code,{children:"Context"})," directly in a parameter thanks to\nhelper types exported by ",(0,o.jsx)(n.code,{children:"@modular-component/core/extend"}),": ",(0,o.jsx)(n.code,{children:"GetArgsFor"})," and ",(0,o.jsx)(n.code,{children:"GetValueGetterFor"}),"."]}),"\n",(0,o.jsx)(n.h4,{id:"getargsfor",children:(0,o.jsx)(n.code,{children:"GetArgsFor"})}),"\n",(0,o.jsxs)(n.p,{children:["The first way to expose arguments is to use the ",(0,o.jsx)(n.code,{children:"GetArgsFor"})," helper type. This type is a generic type depending on ",(0,o.jsx)(n.code,{children:"Context"})," and ",(0,o.jsx)(n.code,{children:"Field"}),".\nIt returns the arguments available for that ",(0,o.jsx)(n.code,{children:"Field"}),", keeping track of it internally to provide the correct typing even when the\nfield is overridden later by calling the same stage function again (see ",(0,o.jsx)(n.a,{href:"/docs/usage/reusing-components",children:"Reusing components"}),")."]}),"\n",(0,o.jsxs)(n.p,{children:["You can use it to create a parameter taking a function computing a value from those args, and then call that function in\nthe ",(0,o.jsx)(n.code,{children:"provide"})," transformer of your stage:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { ModularContext, GetArgsFor, addTo } from '@modular-component/core/extend'\n\nfunction stage<\n  Context extends ModularContext,\n  Field extends string,\n  Value\n>(field: Field, useComputeValue: (args: GetArgsFor<Context, Field>) => Value) {\n  return addTo<Context>()\n    .on(field)\n    .provide((args) => useComputeValue(args)) \n}\n"})}),"\n",(0,o.jsxs)(n.h4,{id:"getvaluegetterfor-and-wrap-recommended",children:[(0,o.jsx)(n.code,{children:"GetValueGetterFor"})," and ",(0,o.jsx)(n.code,{children:"wrap"})," (recommended)"]}),"\n",(0,o.jsxs)(n.p,{children:["Rather than forcing your users to provide a function each time, you can opt for letting them choose between a function\nor a direct value through the ",(0,o.jsx)(n.code,{children:"GetValueGetterFor"}),". This type takes the ",(0,o.jsx)(n.code,{children:"Context"})," and ",(0,o.jsx)(n.code,{children:"Field"})," and a third ",(0,o.jsx)(n.code,{children:"Type"})," parameter (which can be generic too!)\nand creates a type accepting either a raw value of type ",(0,o.jsx)(n.code,{children:"Type"}),", or a function of type ",(0,o.jsx)(n.code,{children:"(args: GetArgsFor<Context, Field>) => Type"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["In order to safely use that value with the provided ",(0,o.jsx)(n.code,{children:"args"})," object, you can use the ",(0,o.jsx)(n.code,{children:"wrap"})," helper provided by ",(0,o.jsx)(n.code,{children:"@modular-component/core/extend"})," to\nwrap a raw value inside a function:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"import { ModularContext, GetValueGetterFor, addTo, wrap } from '@modular-component/core/extend'\n\nfunction stage<\n  Context extends ModularContext,\n  Field extends string,\n  Value\n>(field: Field, useComputeValue: GetValueGetterFor<Context, Field, Value>) {\n  return addTo<Context>()\n    .on(field)\n    .provide((args) => wrap(useComputeValue)(args)) \n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"constraining-the-return-type",children:"Constraining the return type"}),"\n",(0,o.jsxs)(n.p,{children:["Since fields can be overridden by providing the same stage function later down the chain (see ",(0,o.jsx)(n.a,{href:"/docs/usage/reusing-components",children:"Reusing components"}),"),\nyou will want to restrict the type of your return values to match what was previously provided. You can do that through the ",(0,o.jsx)(n.code,{children:"GetConstraintFor"}),"\ntype provided by ",(0,o.jsx)(n.code,{children:"@modular-component/core/extend"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"GetConstraintFor"})," type accepts three generic values: ",(0,o.jsx)(n.code,{children:"Context"}),", ",(0,o.jsx)(n.code,{children:"Field"}),", and an optional ",(0,o.jsx)(n.code,{children:"Default"})," value to restrict\nthe value provided the very first time."]}),"\n",(0,o.jsxs)(n.p,{children:["For instance, our ",(0,o.jsx)(n.a,{href:"/docs/extensions/official/with-lifecycle",children:(0,o.jsx)(n.code,{children:"lifecycle"})})," extension makes sure the value returned\nfrom a lifecycle stage starts as an object, and if overridden, respects the contract set up by previous calls:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export function lifecycle<\n  Context extends ModularContext,\n  Type extends GetConstraintFor<Context, 'lifecycle', {}>,\n>(useLifecycle: GetValueGetterFor<Context, 'lifecycle', Type>) {\n  return addTo<Context>().on('lifecycle').provide(wrap(useLifecycle))\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can also use ",(0,o.jsx)(n.code,{children:"GetConstraintFor"})," in more complex types, such as this version of our ",(0,o.jsx)(n.code,{children:"locale"})," stage from earlier\nwhich makes sure any further calls are limited to key prefixes containing the same sub-values as the previously provided one:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { ModularContext, addTo } from '@modular-component/core/extend'\nimport { AvailablePrefixes, GetterFromPrefix, useTranslation } from './locale-system'\n\ntype KeyPrefixConstraint<Context extends ModularContext> = {\n  [prefix in AvailablePrefixes]: GetterFromPrefix<prefix> extends GetConstraintFor<Context, 'locale'>\n    ? prefix : never\n}[AvailablePrefixes]\n\nexport function locale<\n  Context extends ModularContext,\n  KeyPrefix extends KeyPrefixConstraint<Context>,\n>(keyPrefix: KeyPrefix) {\n  return addTo<Context>()\n    .on('locale')\n    .provide(\n      (): GetterFromPrefix<KeyPrefix> =>\n        useTranslation(keyPrefix),\n    )\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"providing-a-type-for-registering-the-stage",children:"Providing a type for registering the stage"}),"\n",(0,o.jsxs)(n.p,{children:["Since a stage provider function can either be used with the ",(0,o.jsx)(n.code,{children:".with()"})," method, or ",(0,o.jsx)(n.a,{href:"#registering-the-stage",children:"registered"})," as its own ",(0,o.jsx)(n.code,{children:"with<Stage>"})," method,\nyou will want to provide type information for the registration."]}),"\n",(0,o.jsxs)(n.p,{children:["This can be easily achieved through two helpers types provided by ",(0,o.jsx)(n.code,{children:"@modular-component/core/extend"}),": ",(0,o.jsx)(n.code,{children:"StageParams"})," and ",(0,o.jsx)(n.code,{children:"StageReturn"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Since our stages often take generic parameters, it is not possible to have a single helper type that infers the complete registration\ntype from your function. You will still need to manually create a type where your generics are provided:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { ModularContext, GetValueGetterFor, GetConstraintFor, StageParams, StageReturn, addTo, wrap } from '@modular-component/core/extend'\nimport { AvailablePrefixes, GetterFromPrefix, useTranslation } from './locale-system'\n\ntype KeyPrefixConstraint<Context extends ModularContext> = {\n  [prefix in AvailablePrefixes]: GetterFromPrefix<prefix> extends GetConstraintFor<Context, 'locale'>\n    ? prefix : never\n}[AvailablePrefixes]\n\nexport function locale<\n  Context extends ModularContext,\n  KeyPrefix extends KeyPrefixConstraint<Context>,\n>(keyPrefix: KeyPrefix) {\n  return addTo<Context>()\n    .on('locale')\n    .provide(\n      (): GetterFromPrefix<KeyPrefix> =>\n        useTranslation(keyPrefix),\n    )\n}\n\n// highlight-next-line\nexport type WithLocale<\n  // highlight-next-line\n  Context extends ModularContext\n  // highlight-next-line\n> = <\n  // highlight-next-line\n  KeyPrefix extends KeyPrefixConstraint<Context>,\n  // highlight-next-line\n>(\n  // highlight-next-line\n  ...args: StageParams<typeof locale<Context, KeyPrefix>>\n  // highlight-next-line\n) => StageReturn<typeof locale<Context, KeyPrefix>>\n\nexport function stage<\n  Context extends ModularContext,\n  Field extends string,\n  Value\n>(field: Field, useComputeValue: GetValueGetterFor<Context, Field, Value>) {\n  return addTo<Context>()\n    .on(field)\n    .provide((args) => wrap(useComputeValue)(args)) \n}\n\n// highlight-next-line\nexport type WithStage<\n  // highlight-next-line\n  Context extends ModularContext\n  // highlight-next-line\n> = <\n  // highlight-next-line\n  Field extends string,\n  // highlight-next-line\n  Value\n  // highlight-next-line\n>(\n  // highlight-next-line\n  ...args: StageParams<typeof stage<Context, Field, Value>>\n  // highlight-next-line\n) => StageReturn<typeof stage<Context, Field, Value>>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can see the parallels between the function and the type definition: we find the same generic types, except for ",(0,o.jsx)(n.code,{children:"Context"}),"\nwhich is provided through the type directly. All other generics must be defined as generics of the returned function to\nbe inferred through the given parameters."]}),"\n",(0,o.jsx)(n.h2,{id:"registering-the-stage",children:"Registering the stage"}),"\n",(0,o.jsxs)(n.p,{children:["You can register your custom stages to make them readily available on ",(0,o.jsx)(n.code,{children:"ModularComponents"})," without needing\nto import them. Registering a stage ",(0,o.jsx)(n.code,{children:"stage"})," will add a new ",(0,o.jsx)(n.code,{children:".withStage"})," method to your ",(0,o.jsx)(n.code,{children:"ModularComponents"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Registering the stage is a two-steps process."}),"\n",(0,o.jsx)(n.h3,{id:"registering-the-runtime-implementation",children:"Registering the runtime implementation"}),"\n",(0,o.jsxs)(n.p,{children:["You can register stages by calling the ",(0,o.jsx)(n.code,{children:"ModularComponent.register()"})," function. Calling ",(0,o.jsx)(n.code,{children:"register()"})," multiple times do not replace the registered stages, instead it merges them."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\nimport { locale, stage } from './custom-stages'\n\nModularComponent.register({ locale, stage })\n"})}),"\n",(0,o.jsxs)(n.admonition,{type:"tip",children:[(0,o.jsxs)(n.p,{children:["Make sure to import the module where your register runtime implementations ",(0,o.jsx)(n.em,{children:"before"})," any module using ",(0,o.jsx)(n.code,{children:"ModularComponent"}),",\nso that the stages are actually made available."]}),(0,o.jsxs)(n.p,{children:["You can optionally ",(0,o.jsxs)(n.em,{children:["re-export ",(0,o.jsx)(n.code,{children:"ModularComponent"})]})," from a module doing the registration, and always use this import\nin your app."]})]}),"\n",(0,o.jsx)(n.h3,{id:"registering-the-typing-information",children:"Registering the typing information"}),"\n",(0,o.jsxs)(n.p,{children:["You can use the ",(0,o.jsx)(n.a,{href:"#providing-a-type-for-registering-the-stage",children:"types"})," created above to register\nyour stages typing information so that the TypeScript compiler becomes aware of them."]}),"\n",(0,o.jsxs)(n.p,{children:["Simply redeclare ",(0,o.jsx)(n.code,{children:"@modular-component/stages"})," to extend the ",(0,o.jsx)(n.code,{children:"ModularComponentStages"})," interface\nwith your stages:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import type { WithLocale, WithStage } from './custom-stages'\n\ndeclare module '@modular-component/stages' {\n  export interface ModularComponentStages<Context extends ModularContext> {\n    withLocale: WithLocale<Context>\n    withStage: WithStage<Context>\n  }\n}\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"tip",children:(0,o.jsxs)(n.p,{children:["In a TypeScript project, the ",(0,o.jsx)(n.code,{children:"ModularComponent.register()"})," function will throw an error\nif you pass a stage that was not added to the ",(0,o.jsx)(n.code,{children:"ModularComponentStages"})," interface."]})}),"\n",(0,o.jsx)(n.h2,{id:"putting-it-together",children:"Putting it together"}),"\n",(0,o.jsx)(n.p,{children:'Here is a full example of a "define -> register -> use" loop, for a stage that injects an analytics tracker.\nThe tracker itself lives outside the component, so opting into tracking is now a one-line action in each component.'}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",metastring:'title="services/analytics.ts"',children:"export const analyticsTracker = {\n  track({ component, event, props, extra }: {\n    component: string\n    event: string\n    props: Record<string, unknown>\n    extra?: Record<string, unknown>\n  }) {\n    console.log('[track]', component, event, props, extra)\n  },\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",metastring:'title="custom-stages/with-tracking.ts"',children:"import { ModularComponent, ModularContext } from '@modular-component/core'\nimport { addTo, StageParams, StageReturn } from '@modular-component/core/extend'\nimport { analyticsTracker } from '../services/analytics'\n\n// Definition\nfunction tracking<Context extends ModularContext>(\n  componentName: string,\n) {\n  return addTo<Context>()\n    .on('tracking')\n    .provide(({ props }) => ({\n      track(event: string, extra?: Record<string, unknown>) {\n        analyticsTracker.track({\n          component: componentName,\n          event,\n          props,\n          extra,\n        })\n      },\n    }))\n}\n\ntype WithTracking<Context extends ModularContext> = (\n  ...args: StageParams<typeof tracking<Context>>\n) => StageReturn<typeof tracking<Context>>\n\n// Registration\nModularComponent.register({ tracking })\n\ndeclare module '@modular-component/stages' {\n  interface ModularComponentStages<Context extends ModularContext> {\n    withTracking: WithTracking<Context>\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The registration makes ",(0,o.jsx)(n.code,{children:".withTracking"})," available everywhere. A component only has to provide its label once;\nthe tracker is injected through the stage so consumers never import it directly."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",metastring:'title="TrackedButton.tsx"',children:"import { ModularComponent } from '@modular-component/core'\n\nexport const TrackedButton = ModularComponent<{ label: string }>()\n  .withTracking('TrackedButton')\n  .withRender(({ props, tracking }) => {\n    tracking.track('rendered')\n\n    return <button>{props.label}</button>\n  })\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"tracking"})," argument is available for all stages downstream from ",(0,o.jsx)(n.code,{children:"withTracking"}),", making it easy\nto track actions within that component."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var r=t(6540);const o={},i=r.createContext(o);function a(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);
"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[309],{2190:(n,e,o)=>{o.r(e),o.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"extensions/official/with-conditional-render","title":"@modular-component/with-conditional-render","description":"Provides three stages that allow conditional rendering in ModularComponents:","source":"@site/docs/extensions/official/with-conditional-render.md","sourceDirName":"extensions/official","slug":"/extensions/official/with-conditional-render","permalink":"/docs/extensions/official/with-conditional-render","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/extensions/official/with-conditional-render.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"defaultSidebar","previous":{"title":"@modular-component/with-components","permalink":"/docs/extensions/official/with-components"},"next":{"title":"@modular-component/with-fragment","permalink":"/docs/extensions/official/with-fragment"}}');var i=o(4848),d=o(8453);const r={sidebar_position:5},a="@modular-component/with-conditional-render",l={},c=[{value:"Usage",id:"usage",level:2},{value:"Multiple conditions and fallbacks",id:"multiple-conditions-and-fallbacks",level:2},{value:"Stage registration",id:"stage-registration",level:2},{value:"Implementation",id:"implementation",level:2}];function s(n){const e={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"modular-componentwith-conditional-render",children:"@modular-component/with-conditional-render"})}),"\n",(0,i.jsxs)(e.p,{children:["Provides three stages that allow conditional rendering in ",(0,i.jsx)(e.code,{children:"ModularComponents"}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"condition()"})," will set a customizable argument to either ",(0,i.jsx)(e.code,{children:"true"})," or ",(0,i.jsx)(e.code,{children:"false"}),", based\non current arguments,"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"conditionalFallback()"})," takes a ",(0,i.jsx)(e.code,{children:"FunctionComponent"})," as parameter, and\nrenders it when a customizable argument is set to ",(0,i.jsx)(e.code,{children:"true"}),", filling the ",(0,i.jsx)(e.code,{children:"render"})," argument in the process,"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"conditionalRender()"})," also takes a ",(0,i.jsx)(e.code,{children:"FunctionComponent"})," as parameter, and\nrenders it only if the ",(0,i.jsx)(e.code,{children:"render"})," argument was not filled earlier."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(e.admonition,{type:"warning",children:[(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"conditionalFallback"})," and ",(0,i.jsx)(e.code,{children:"conditionalRender"}),"'s stage functions are executed ",(0,i.jsx)(e.em,{children:"conditionally"}),"."]}),(0,i.jsxs)(e.p,{children:["If the provided ",(0,i.jsx)(e.code,{children:"condition"})," isn't met, ",(0,i.jsx)(e.code,{children:"conditionalFallback"})," does not run its function. If a ",(0,i.jsx)(e.code,{children:"conditionalFallback"})," ran earlier,\n",(0,i.jsx)(e.code,{children:"conditionalRender"})," won't run its function."]}),(0,i.jsx)(e.p,{children:"As such, neither of those functions can have hook calls inside, otherwise the rule of hooks can be broken during\nrerenders."})]}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Stage function imports"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\nimport { lifecycle } from '@modular-component/with-lifecycle'\nimport {\n  condition,\n  conditionalFallback,\n  conditionalRender,\n} from '@modular-component/with-conditional-render'\n\nconst ConditionalComponent = ModularComponent<{ enabled?: boolean }>()\n  .with(\n    lifecycle(() => {\n      // Some data fetching logic...\n      return { loading, data }\n    }),\n  )\n  .with(condition('disabled', ({ props }) => props.enabled !== true))\n  .with(conditionalFallback('disabled', () => <>I'm disabled!</>))\n  .with(condition('loading', ({ lifecycle }) => lifecycle.loading))\n  .with(conditionalFallback('loading', () => <>I'm loading!</>))\n  .with(\n    conditionalRender(({ lifecycle }) => (\n      <>I'm enabled and loaded, here is the content: {lifecycle.data}</>\n    )),\n  )\n"})}),"\n",(0,i.jsx)(e.p,{children:(0,i.jsx)(e.strong,{children:"Stage registration"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\nimport '@modular-component/with-lifecycle/register'\nimport '@modular-component/with-conditional-render/register'\n\nconst ConditionalComponent = ModularComponent<{ enabled?: boolean }>()\n  .withLifecycle(() => {\n    // Some data fetching logic...\n    return { loading, data }\n  })\n  .withCondition('disabled', ({ props }) => props.enabled !== true)\n  .withConditionalFallback('disabled', () => <>I'm disabled!</>)\n  .withCondition('loading', ({ lifecycle }) => lifecycle.loading)\n  .withConditionalFallback('loading', () => <>I'm loading!</>)\n  .withConditionalRender(({ lifecycle }) => (\n    <>I'm enabled and loaded, here is the content: {lifecycle.data}</>\n  ))\n"})}),"\n",(0,i.jsx)(e.h2,{id:"multiple-conditions-and-fallbacks",children:"Multiple conditions and fallbacks"}),"\n",(0,i.jsxs)(e.p,{children:["You can use the ",(0,i.jsx)(e.code,{children:"condition"})," and ",(0,i.jsx)(e.code,{children:"conditionalFallback"})," multiple times in the same pipeline by providing different\nargument names as the first parameter."]}),"\n",(0,i.jsx)(e.h2,{id:"stage-registration",children:"Stage registration"}),"\n",(0,i.jsxs)(e.p,{children:["You can either automatically register the stages on ",(0,i.jsx)(e.code,{children:"withCondition"}),", ",(0,i.jsx)(e.code,{children:"withConditionalFallback"})," and ",(0,i.jsx)(e.code,{children:"withConditionalRender"})," by importing ",(0,i.jsx)(e.code,{children:"@modular-component/with-conditional-render/register"}),",\nor handle the registration manually thanks to the ",(0,i.jsx)(e.code,{children:"condition"}),", ",(0,i.jsx)(e.code,{children:"conditionalFallback"}),", ",(0,i.jsx)(e.code,{children:"conditionalRender"})," functions and ",(0,i.jsx)(e.code,{children:"WithCondition"}),", ",(0,i.jsx)(e.code,{children:"WithConditionalFallback"}),", ",(0,i.jsx)(e.code,{children:"WithConditionalRender"})," types exports."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-ts",children:"import { ModularComponent, ModularContext } from '@modular-component/core'\nimport {\n  condition,\n  conditionalFallback,\n  conditionalRender,\n  WithCondition,\n  WithConditionalFallback,\n  WithConditionalRender,\n} from '@modular-component/with-conditional-render'\n\n// Register the stages on the factory\nModularComponent.register({ condition, conditionalFallback, conditionalRender })\n\n// Extend the type definition\ndeclare module '@modular-component/stages' {\n  export interface ModularComponentStages<Context extends ModularContext> {\n    withCondition: WithCondition<Context>\n    withConditionalFallback: WithConditionalFallback<Context>\n    withConditionalRender: WithConditionalRender<Context>\n  }\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(e.p,{children:"The implementation for those stages is a bit more involved than other official extensions. Here, we have restrictions\nfor each stage, as well as stage hooks."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-tsx",children:"import { FunctionComponent } from 'react'\nimport {\n  addTo,\n  wrap,\n  ModularContext,\n  GetValueGetterFor,\n  StageParams,\n  StageReturn,\n} from '@modular-component/core/extend'\n\ntype GetConditions<Context extends ModularContext> = {\n  [key in keyof Context['arguments']]: Context['arguments'][key] extends boolean\n    ? key extends string\n      ? key\n      : never\n    : never\n}[keyof Context['arguments']]\n\nexport function condition<\n  Context extends ModularContext, \n  Field extends string\n>(\n  field: Field,\n  useCondition: GetValueGetterFor<Context, Field, boolean>,\n) {\n  return addTo<Context>().on(field).provide(wrap(useCondition))\n}\n\nexport type WithCondition<\n  Context extends ModularContext\n> = <\n  Field extends string,\n>(\n  ...args: StageParams<typeof condition<Context, Field>>\n) => StageReturn<typeof condition<Context, Field>>\n\nexport function conditionalFallback<\n  Context extends ModularContext,\n  Condition extends GetConditions<Context>,\n>(\n  condition: Condition,\n  useRender: GetValueGetterFor<\n    Context,\n    `render-${Condition}`,\n    ReturnType<FunctionComponent>\n  >,\n) {\n  return addTo<Context>()\n    .on(`render-${condition}`)\n    .provide((args) => {\n      const _args = args as {\n        [condition]?: boolean\n        render?: ReturnType<FunctionComponent>\n      }\n      if (_args[condition] && !_args.render) {\n        _args.render = wrap(useRender)(args)\n      }\n      return !!_args[condition] as boolean\n    })\n}\n\nexport type WithConditionalFallback<\n  Context extends ModularContext\n> = <\n  Condition extends GetConditions<Context>,\n>(\n  ...args: StageParams<typeof conditionalFallback<Context, Condition>>\n) => StageReturn<typeof conditionalFallback<Context, Condition>>\n\nexport function conditionalRender<Context extends ModularContext>(\n  useRender: GetValueGetterFor<\n    Context,\n    'render',\n    ReturnType<FunctionComponent>\n  >,\n) {\n  return addTo<Context>()\n    .on('render')\n    .provide(\n      (args): ReturnType<FunctionComponent> =>\n        (args as { render?: ReturnType<FunctionComponent> }).render ??\n        wrap(useRender)(args),\n    )\n}\n\nexport type WithConditionalRender<Context extends ModularContext> = (\n  ...args: StageParams<typeof conditionalRender<Context>>\n) => StageReturn<typeof conditionalRender<Context>>\n"})})]})}function h(n={}){const{wrapper:e}={...(0,d.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(s,{...n})}):s(n)}},8453:(n,e,o)=>{o.d(e,{R:()=>r,x:()=>a});var t=o(6540);const i={},d=t.createContext(i);function r(n){const e=t.useContext(d);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function a(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),t.createElement(d.Provider,{value:e},n.children)}}}]);
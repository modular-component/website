"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),c=o,h=m["".concat(s,".").concat(c)]||m[c]||u[c]||i;return n?a.createElement(h,r(r({ref:t},d),{},{components:n})):a.createElement(h,r({ref:t},d))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9881:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:1},r="ModularComponent",l={unversionedId:"intro",id:"intro",title:"ModularComponent",description:"\ud83c\udf5e.with(\ud83c\udf45).with(\ud83e\uddc0) = \ud83e\udd6a",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/docs/intro",draft:!1,editUrl:"https://github.com/modular-component/website/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Building the Factory",permalink:"/docs/usage/building-the-factory"}},s={},p=[{value:"What are Modular Components",id:"what-are-modular-components",level:2},{value:"Installation",id:"installation",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"The factory pipeline",id:"the-factory-pipeline",level:3},{value:"Pipeline stages",id:"pipeline-stages",level:4},{value:"Adding stages",id:"adding-stages",level:4},{value:"Manipulating stages",id:"manipulating-stages",level:4},{value:"Generating hooks",id:"generating-hooks",level:3}],d={toc:p};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"modularcomponent"},"ModularComponent"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\ud83c\udf5e.with(\ud83c\udf45).with(\ud83e\uddc0) = \ud83e\udd6a")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Delightfully organized and deeply testable React Components")),(0,o.kt)("h2",{id:"what-are-modular-components"},"What are Modular Components"),(0,o.kt)("p",null,"Modular Components are React components built through a modular factory, allowing the\naddition of functionality as needed as the component is built."),(0,o.kt)("p",null,"The modular factory approach is built on top of React hooks, and offers out-of-the-box\ncomposition for building and stub injections for testing."),(0,o.kt)("p",null,"It offers best-in-class DX through strong typing and easy separation of concern, and is\ninfinitely extensible thanks to its built-in modular nature."),(0,o.kt)("p",null,'You can think of it as "higher-order hooks", without the awkward chaining of methods\nthanks to the factory pattern.'),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("p",null,"At it simplest, you will need the ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/core")," package to get started with ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent"),"."),(0,o.kt)("p",null,"However, the core module alone does not bring any component capability - it needs plugins,\nor extensions, to start shining \u2728 !"),(0,o.kt)("p",null,"We provide a sensible set of default capabilities through the ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/default")," package.\nIt is highly recommended to install both for getting started."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add @modular-component/core @modular-component/default\n")),(0,o.kt)("p",null,"You can then build your component factory by combining the ",(0,o.kt)("inlineCode",{parentName:"p"},"modularFactory")," export from\n",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/core"),", and the default set of stages exported as ",(0,o.kt)("inlineCode",{parentName:"p"},"WithDefaultStages"),"\nfrom ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/default"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { modularFactory } from '@modular-component/core'\nimport { WithDefaultStages } from '@modular-component/default'\n\nconst ModularComponent = modularFactory.extend(WithDefaultStages).build()\n")),(0,o.kt)("p",null,"From there, you can instantiate new components with the ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," factory function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  .withDefaultProps({ someFlag: false })\n  .withLifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  })\n  .withRender(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  ))\n")),(0,o.kt)("h2",{id:"how-it-works"},"How it works"),(0,o.kt)("h3",{id:"the-factory-pipeline"},"The factory pipeline"),(0,o.kt)("h4",{id:"pipeline-stages"},"Pipeline stages"),(0,o.kt)("p",null,"The main concept behind the ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," approach is the factory pipeline."),(0,o.kt)("p",null,"At its core, a ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," is a set of ordered ",(0,o.kt)("strong",{parentName:"p"},"stages"),", each of which populates\na specific ",(0,o.kt)("strong",{parentName:"p"},"argument")," in a shared object, which gets passed from stage to stage."),(0,o.kt)("p",null,"The last stage (usually, but not necessarily, the ",(0,o.kt)("strong",{parentName:"p"},"render stage"),") has therefore access\nto data computed by every previous stage in the pipeline."),(0,o.kt)("p",null,"This for instance allows separating any stateful lifecycle computation in a dedicated\nstage, and keep the render stage for its main purpose: laying down the markup through JSX."),(0,o.kt)("p",null,'Here is the "getting started" example, complete with comments explaining\nthe pipeline system:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ModularComponent } from '@modular-component/core'\n\nconst MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  // .withDefaultProps modifies the `props` argument to mark\n  // provided props as NonNullable. Here, `someFlag` will be\n  // a `boolean` for all further stages, instead of `boolean | undefined`\n  // as it originally was\n  .withDefaultProps({ someFlag: false })\n  // .withLifecycle receives the modified props from .withDefaultProps\n  // It then uses React hooks to construct our component's internal state\n  .withLifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  })\n  // Finally, .withRender receives both the up-to-date props and the new\n  // lifecycle argument generated by the .withLifecycle stage\n  .withRender(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  ))\n")),(0,o.kt)("h4",{id:"adding-stages"},"Adding stages"),(0,o.kt)("p",null,"Internally, a ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," keeps an array of ordered stages. Calling a stage\nmethod will either append a new stage to the array, or edit an already existing value."),(0,o.kt)("p",null,"There are two main stage methods for each available stage type:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"with{Stage}")," method, as seen is the getting started example, ",(0,o.kt)("em",{parentName:"p"},"upsert")," a stage into the array."),(0,o.kt)("p",{parentName:"li"},"Calling it one time will append the stage at the end of the array; subsequent calls to the same\nstage method will replace the implementation of the stage but keep its position in the pipeline."),(0,o.kt)("p",{parentName:"li"},"Because of this, it's important that the provided value honors the contract set up by the very\nfirst call, otherwise it could break downstream stages depending on it."),(0,o.kt)("p",{parentName:"li"},"When using TypeScript, this is enforced internally, and subsequent calls to an already added stage\nwill be narrowed to force honoring previous contracts.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"add{Stage}")," method ",(0,o.kt)("em",{parentName:"p"},"appends")," a new stage into the array.\nIt can only be called after the ",(0,o.kt)("inlineCode",{parentName:"p"},"with")," method of the same stage has been used at least once."),(0,o.kt)("p",{parentName:"li"},"When calling this method, a new stage of the same type is added at the end of the pipeline,\nleaving the previous stages untouched. The argument generated by the newly added stage will\nonly be available to downstream stages, and upstream stages will keep receiving the value\ngenerated by the previous stage of the type."),(0,o.kt)("p",{parentName:"li"},"Since previous stages are not modified, ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," calls can completely change the value of\nthe field without any impact on upstream stages. For the same reason, the TypeScript definition\nis not restricted."),(0,o.kt)("p",{parentName:"li"},"When calling a ",(0,o.kt)("inlineCode",{parentName:"p"},"with")," method when multiple stages of the same type have been added through ",(0,o.kt)("inlineCode",{parentName:"p"},"add"),",\nthe last stage of the type is edited. It's also possible to pass an optional index\nto edit previous stages instead."))),(0,o.kt)("h4",{id:"manipulating-stages"},"Manipulating stages"),(0,o.kt)("p",null,"We've seen how the ",(0,o.kt)("inlineCode",{parentName:"p"},"with")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"add")," stage methods allow us to append or edit stages\nin our component's pipeline. Additionally, we can further manipulate our pipeline through\ntwo additional stage methods: ",(0,o.kt)("inlineCode",{parentName:"p"},"at")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mock"),"."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"at{Stage}")," stage methods rewind the pipeline to the given stage. If multiple stages of the\nsame type were added through the ",(0,o.kt)("inlineCode",{parentName:"li"},"add")," method, the pipeline is rewound to the last stage of the type.\nAn optional index can also be provided to rewind to a specific occurrence. All downstream\nstages are dropped, while all upstream stages are kept as-is."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"mock{Stage}")," stage methods replace the value generated by a given stage, skipping any transform\nconfigured for the stage (see ",(0,o.kt)("a",{parentName:"li",href:"/docs/extensions/writing-extensions"},"Writing Extension"),").")),(0,o.kt)("p",null,"Combining those two methods is especially powerful for testing stages in isolation: ",(0,o.kt)("inlineCode",{parentName:"p"},"at")," allows\ndropping downstream stages, while ",(0,o.kt)("inlineCode",{parentName:"p"},"mock")," allows stubbing and controlling upstream stages, leaving\nthe currently tested stage isolated in the pipeline."),(0,o.kt)("h3",{id:"generating-hooks"},"Generating hooks"),(0,o.kt)("p",null,"Atop of the factory stages seen previously, ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent"),"s\nalso expose methods for converting our component to a hook:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"asHook"),": extract the stages as a custom hook, returning the map of arguments.\nThis is used internally when calling the generated component, but can also be\nuseful in other situations like tests, or the need to generate a shared hook\nconsuming application context, such as a global store for which a stage exists."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"asUse{Argument}"),": creates a custom hook running our pipeline and returning the\nvalue of one specific argument. Useful in combination with ",(0,o.kt)("inlineCode",{parentName:"li"},"at{Stage}")," to test\nthe returned value of a given stage easily.")),(0,o.kt)("p",null,"Combining those hook methods with ",(0,o.kt)("inlineCode",{parentName:"p"},"at")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mock")," stage methods can be very powerful in testing scenarios. For instance,\none can extract the lifecycle hook of a component by chaining them:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const useLifecycle = MyComponent.atLifecycle().asUseLifecycle()\n")),(0,o.kt)("p",null,"Or one could mock the lifecycle entirely to test the render:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const OnlyRender = MyComponent.mockLifecycle({\n  fromLifecycle: 'hello world',\n})\n")))}u.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[739],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=o.createContext({}),l=function(e){var n=o.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=l(e.components);return o.createElement(p.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(t),u=a,h=d["".concat(p,".").concat(u)]||d[u]||m[u]||i;return t?o.createElement(h,r(r({ref:n},c),{},{components:t})):o.createElement(h,r({ref:n},c))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=d;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<i;l++)r[l]=t[l];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},5572:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var o=t(7462),a=(t(7294),t(3905));const i={sidebar_position:3},r="Reusing Components",s={unversionedId:"usage/reusing-components",id:"usage/reusing-components",title:"Reusing Components",description:"One use case enabled by ModularComponent is reusing component logic at a higher level than component composition,",source:"@site/docs/usage/reusing-components.md",sourceDirName:"usage",slug:"/usage/reusing-components",permalink:"/docs/usage/reusing-components",draft:!1,editUrl:"https://github.com/modular-component/website/docs/usage/reusing-components.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Writing Hooks",permalink:"/docs/usage/writing-hooks"},next:{title:"Testing Components",permalink:"/docs/usage/testing-components"}},p={},l=[{value:"Replacing the render phase",id:"replacing-the-render-phase",level:2},{value:"Replacing a custom stage",id:"replacing-a-custom-stage",level:2}],c={toc:l};function m(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"reusing-components"},"Reusing Components"),(0,a.kt)("p",null,"One use case enabled by ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent")," is reusing component logic at a higher level than component composition,\nbut a more specific level than extracting logic into hooks."),(0,a.kt)("p",null,"This is permitted by two characteristics of ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The factory is immutable, meaning that each new stage addition creates a brand-new component, leaving the previous\none untouched,"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"with")," method called on an existing field ",(0,a.kt)("em",{parentName:"li"},"replaces the previous implementation at its current position in the pipeline"),",\nrather than adding a new stage.")),(0,a.kt)("p",null,"Thanks to that, it's possible to take a full-fledged component, and replace only specific stages to create a slightly\ndifferent component. For instance, once could replace the lifecycle stage of a component while keeping the render stage\nthe same; or the other way around, keep a component logic, but switch the render phase."),(0,a.kt)("h2",{id:"replacing-the-render-phase"},"Replacing the render phase"),(0,a.kt)("p",null,"Imagine a component that needs to be used in both a web-based application, and a React Native application. Since React Native\nand the web don't share their primitive components (HTML tags on the web, and built-in components (Text, View...) in React Native),\nonly the logic can be reused."),(0,a.kt)("p",null,"Before the introduction of hooks, the recommended way to deal with that was to create a ",(0,a.kt)("em",{parentName:"p"},"headless")," component for handling\nthe logic, that then passed it down to a ",(0,a.kt)("em",{parentName:"p"},"dumb")," component either via props (using a render function for instance), or via context:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { MyComponentHeadlessLogic } from './my-component.headless-logic'\n\nconst MyWebInterface = (props) => (\n  // Something web specific\n)\n\nexport const MyWebComponent = (props) => (\n  <MyComponentHeadlessLogic {...props}>{p => <MyWebInterface {...p} />}</MyComponentHeadlessLogic>\n)\n\nconst MyNativeInterface = (props) => (\n  // Something react-native specific\n)\n\nexport const MyNativeComponent = (props) => (\n  <MyComponentHeadlessLogic {...props}>{p => <MyNativeInterface {...p} />}</MyComponentHeadlessLogic>\n)\n")),(0,a.kt)("p",null,"While there is nothing wrong with this approach, we still end up creating 5 components where we really only need 2."),(0,a.kt)("p",null,"With the introduction of hooks, the headless logic could instead be abstracted to a custom hook, that can be consumed\nby both our implementations:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { useMyComponentLogic, MyComponentProps } from './use-my-component-logic'\n\nexport const MyWebComponent = (props: MyComponentProps) => {\n  const logic = useMyComponentLogic(props)\n  \n  return (\n    // Something web specific\n  )\n}\n\nexport const MyNativeComponent = (props: MyComponentProps) => {\n  const logic = useMyComponentLogic(props)\n\n  return (\n    // Something react-native specific\n  )\n}\n")),(0,a.kt)("p",null,"This is already much better, we only deal with 2 components this time, with one shared hook for the logic, and one\nshared type for the props."),(0,a.kt)("p",null,"But what if we could simply ",(0,a.kt)("em",{parentName:"p"},"reuse a main component definition"),", which would already handle the logic and the props\ndefinition, and concentrate on what matters here: the platform-specific implementation?"),(0,a.kt)("p",null,"Here is how this could look like using ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"export const MyWebComponent = ModularComponent<{\n  // Inline props type definition\n}>()\n  .with(lifecycle(({ props }) => {\n    // Shared logic, can consume the props\n  }))\n  .with(render(({ props, lifecycle }) => (\n    // Web-specific interface, can consume the props and the state\n  )))\n\nexport const MyNativeComponent = MyWebComponent\n  // Replace only the render stage\n  .with(render(({ props, lifecycle }) => (\n    // React native-specific interface, can consume the props and the state\n  )))\n")),(0,a.kt)("p",null,"This is even better! Now we only have two variables to jungle with, and those are the two components we wanted to create\nin the first place."),(0,a.kt)("p",null,"Our logic and props type are reusable without having to pass a function and type definition around."),(0,a.kt)("h2",{id:"replacing-a-custom-stage"},"Replacing a custom stage"),(0,a.kt)("p",null,"There are also cases where a shared render stage (and even shared custom stages) makes a lot of sense. Let's take a concrete\nexample: an application with a signup confirmation flow, and a password reinitialisation flow. Both those flows share\ntwo steps in common: "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},'After submitting the signup form or an email for password reinitialisation, a "confirmation email sent" screen is\ndisplayed, optionally allowing to resend a new one.'),(0,a.kt)("li",{parentName:"ol"},'After confirming the signup/setting the new password, a final "your account is now ready"/"your new password is now ready"\nscreen is displayed.')),(0,a.kt)("p",null,"Both those screens share a lot of things, both in terms of logic and layout. The small variations between them are mostly\nin copy, and a small bit of logic to send the correct email upon request."),(0,a.kt)("p",null,"All of this can easily be done using ",(0,a.kt)("inlineCode",{parentName:"p"},"ModularComponent"),', with minimal duplication and maximal reuse. Let\'s take the\n"confirmation email sent" screen as example:'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"export const SignupConfirmationEmailSent = ModularComponent()\n  // Localization data for our signup confirmation screen\n  .with(locale('screens.signup.confirmation-email-sent'))\n  .with(defaultProps({\n    resendEmail: () => {\n      // Logic to resend the email for signup confirmation\n    }\n  }))\n  .with(lifecycle(({ props }) => {\n    // Shared screen logic: opening the \"resend email\" confirmation modal, calling props.resendEmail when needed...\n  }))\n  .with(render(({ props, lifecycle, locale }) => (\n    // Shared render: consume the passed locale for the copy, has access to props and the lifecycle logic\n  )))\n\nexport const PasswordResetConfirmationEmailSent = SignupConfirmationEmailSent\n  // Replace the locale with the password-reset variant. As long as the keys are the same, the render will keep working\n  .with(locale('screens.password-reset.confirmation-email-sent'))\n  .with(defaultProps({\n    resendEmail: () => {\n      // Different logic to resend the email for password reset\n    }\n  }))\n")),(0,a.kt)("p",null,"As we can see, the ",(0,a.kt)("inlineCode",{parentName:"p"},"PasswordResetConfirmationEmailSent")," implementation is really simple, reusing both the lifecycle\nand render stages of the ",(0,a.kt)("inlineCode",{parentName:"p"},"SignupConfirmationEmailSent"),", simply switching up the locale and ",(0,a.kt)("inlineCode",{parentName:"p"},"resendEmail")," implementations."))}m.isMDXComponent=!0}}]);
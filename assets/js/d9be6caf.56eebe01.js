"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8833],{7319:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>p});const o=JSON.parse('{"id":"extensions/official/with-default-props","title":"@modular-component/with-default-props","description":"Provides a defaultProps() stage allowing to set default values for props. Contrary to the standard React defaultProps","source":"@site/docs/extensions/official/with-default-props.md","sourceDirName":"extensions/official","slug":"/extensions/official/with-default-props","permalink":"/docs/extensions/official/with-default-props","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/extensions/official/with-default-props.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"defaultSidebar","previous":{"title":"@modular-component/default","permalink":"/docs/extensions/official/default"},"next":{"title":"@modular-component/with-lifecycle","permalink":"/docs/extensions/official/with-lifecycle"}}');var r=t(4848),a=t(8453);const s={sidebar_position:2},l="@modular-component/with-default-props",i={},p=[{value:"Usage",id:"usage",level:2},{value:"Stage registration",id:"stage-registration",level:2},{value:"Implementation",id:"implementation",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"modular-componentwith-default-props",children:"@modular-component/with-default-props"})}),"\n",(0,r.jsxs)(n.p,{children:["Provides a ",(0,r.jsx)(n.code,{children:"defaultProps()"})," stage allowing to set default values for props. Contrary to the standard React ",(0,r.jsx)(n.code,{children:"defaultProps"}),"\nfield, the ",(0,r.jsx)(n.code,{children:"defaultProps()"})," stage can also ",(0,r.jsx)(n.em,{children:"set new props"})," that are not surfaced by the component, and react to passed\nprops (or other previous stages) to dynamically compute a default value."]}),"\n",(0,r.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Stage function imports"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { ModularComponent, render } from '@modular-component/core'\nimport { defaultProps } from '@modular-component/with-default-props'\n\nconst MyComponent = ModularComponent<{ someFlag?: boolean }>()\n  .with(\n    defaultProps({\n      someFlag: false,\n      someNewProp: 'hello world',\n    }),\n  )\n  .with(\n    render(({ props }) => {\n      // props is inferred as { someFlag: boolean; someNewProp: string } at this point\n    }),\n  )\n\nconst MyDynamicProps = ModularComponent<{\n  role: 'user' | 'owner' | 'admin'\n  canEdit?: boolean\n  canDelete?: boolean\n}>()\n  .with(\n    defaultProps(({ props }) => ({\n      canEdit: ['owner', 'admin'].includes(props.role),\n      canDelete: ['owner'].includes(props.role),\n    })),\n  )\n  .with(\n    render(({ props }) => {\n      // props is inferred as { role: 'user' | 'owner' | 'admin'; canEdit: boolean; canDelete: boolean }\n      // canEdit defaults to true if the role is not \"user\", false otherwise\n      // canDelete defaults to true if the role is \"admin\", false otherwise\n      // canEdit and canDelete can still be controlled by explicitly setting the property\n    }),\n  )\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Stage registration"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import { ModularComponent } from '@modular-component/core'\nimport '@modular-component/core/register'\nimport '@modular-component/with-default-props/register'\n\nconst MyComponent = ModularComponent<{ someFlag?: boolean }>()\n  .withDefaultProps({\n    someFlag: false,\n    someNewProp: 'hello world',\n  })\n  .withRender(({ props }) => {\n    // props is inferred as { someFlag: boolean; someNewProp: string } at this point\n  })\n\nconst MyDynamicProps = ModularComponent<{\n  role: 'user' | 'owner' | 'admin'\n  canEdit?: boolean\n  canDelete?: boolean\n}>()\n  .withDefaultProps(({ props }) => ({\n    canEdit: ['owner', 'admin'].includes(props.role),\n    canDelete: ['owner'].includes(props.role),\n  }))\n  .withRender(({ props }) => {\n    // props is inferred as { role: 'user' | 'owner' | 'admin'; canEdit: boolean; canDelete: boolean }\n    // canEdit defaults to true if the role is not \"user\", false otherwise\n    // canDelete defaults to true if the role is \"admin\", false otherwise\n    // canEdit and canDelete can still be controlled by explicitly setting the property\n  })\n"})}),"\n",(0,r.jsx)(n.h2,{id:"stage-registration",children:"Stage registration"}),"\n",(0,r.jsxs)(n.p,{children:["You can either automatically register the stage on ",(0,r.jsx)(n.code,{children:"withDefaultProps"})," by importing ",(0,r.jsx)(n.code,{children:"@modular-component/with-default-props/register"}),",\nor handle the registration manually thanks to the ",(0,r.jsx)(n.code,{children:"defaultProps"})," function and ",(0,r.jsx)(n.code,{children:"WithDefaultProps"})," type exports."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { ModularComponent, ModularContext } from '@modular-component/core'\nimport {\n  defaultProps,\n  WithDefaultProps,\n} from '@modular-component/with-default-props'\n\n// Register the stage on the factory\nModularComponent.register({ defaultProps })\n\n// Extend the type definition\ndeclare module '@modular-component/stages' {\n  export interface ModularComponentStages<Context extends ModularContext> {\n    withDefaultProps: WithDefaultProps<Context>\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"defaultProps"})," runs a custom stage hook to shallowly merge the default props to the received component props.\nAccepted values are restricted to a partial map of the original props to only accept correct types for defined props.\nThe value can also be a function of the current args."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import {\n  addTo,\n  wrap,\n  ModularContext,\n  GetConstraintFor,\n  GetValueGetterFor,\n  StageParams,\n  StageReturn,\n} from '@modular-component/core/extend'\n\n// Helper types for building the merged type,\n// marking nullable fields as optional\ntype NonNullableFields<Type> = {\n  [key in keyof Type]-?: undefined extends Type[key] ? never : key\n}[keyof Type]\ntype NullableFields<Type> = {\n  [key in keyof Type]: undefined extends Type[key] ? key : never\n}[keyof Type]\ntype OptionalNullable<Type> = {\n  [key in NonNullableFields<Type>]: Type[key]\n} & {\n  [key in NullableFields<Type>]?: Type[key]\n}\n\n// Main merge helper merging the props and default props,\n// marking props with a default value as non-optional anymore\ntype Merge<Props, DefaultProps extends Partial<Props>> = OptionalNullable<{\n  [key in keyof Props | keyof DefaultProps]-?: key extends keyof Props\n    ? key extends keyof DefaultProps\n      ? Props[key] extends undefined | infer U\n        ? U\n        : Props[key]\n      : Props[key]\n    : DefaultProps[key]\n}> extends infer U\n  ? { [key in keyof U]: U[key] }\n  : never\n\n// Helper type to find fields that lost their optional marker\n// due to a previously defined default prop, in order to\n// constrain the type of further calls to with(defaultProps)\ntype OnlyRequiredInConstraint<Original, Constraint> = {\n  [key in keyof Constraint & keyof Original]: undefined extends Original[key]\n    ? undefined extends Constraint[key]\n      ? never\n      : key\n    : never\n}[keyof Constraint & keyof Original]\n\n// Constrain the field to a partial representation of props,\n// plus any field that previously received a default value in a\n// previous instance of with(defaultProps)\ntype Constraint<Context extends ModularContext> = Partial<Context['props']> &\n  Pick<\n    GetConstraintFor<Context, 'props'>,\n    OnlyRequiredInConstraint<\n      Context['props'],\n      GetConstraintFor<Context, 'props'>\n    >\n  > extends infer U\n  ? { [key in keyof U]: U[key] }\n  : never\n\nexport function defaultProps<\n  Context extends ModularContext,\n  Default extends Constraint<Context>,\n>(useDefault: GetValueGetterFor<Context, 'props', Default>) {\n  return addTo<Context>()\n    .on('props')\n    .provide((args): Merge<Context['props'], Default> => {\n      const defaultProps = wrap(useDefault)(args)\n      return {\n        ...defaultProps,\n        ...(args as { props: Context['props'] }).props,\n      }\n    })\n}\n\nexport type WithDefaultProps<\n  Context extends ModularContext\n> = <\n  Default extends Constraint<Context>,\n>(\n  ...args: StageParams<typeof defaultProps<Context, Default>>\n) => StageReturn<typeof defaultProps<Context, Default>>\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>l});var o=t(6540);const r={},a=o.createContext(r);function s(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);
"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6446],{7285:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"usage/testing-components","title":"Testing Components","description":"Finally, the last interesting use-case enabled by using ModularComponent is component testing. In particular,","source":"@site/docs/usage/testing-components.md","sourceDirName":"usage","slug":"/usage/testing-components","permalink":"/docs/usage/testing-components","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/usage/testing-components.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"defaultSidebar","previous":{"title":"Reusing Components","permalink":"/docs/usage/reusing-components"},"next":{"title":"The extension system","permalink":"/docs/extensions/writing-extensions"}}');var o=t(4848),r=t(8453);const a={sidebar_position:5},i="Testing Components",l={},c=[{value:"Rationale",id:"rationale",level:2},{value:"Testing lifecycle in isolation",id:"testing-lifecycle-in-isolation",level:2},{value:"Testing the render phase with controlled lifecycle",id:"testing-the-render-phase-with-controlled-lifecycle",level:2},{value:"Abstracting sub-components in composed components",id:"abstracting-sub-components-in-composed-components",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"testing-components",children:"Testing Components"})}),"\n",(0,o.jsxs)(n.p,{children:["Finally, the last interesting use-case enabled by using ",(0,o.jsx)(n.code,{children:"ModularComponent"})," is component testing. In particular,\nit allows writing component tests as true ",(0,o.jsx)(n.strong,{children:"unit-tests"}),", instead of semi-integration tests."]}),"\n",(0,o.jsxs)(n.admonition,{title:"Disclaimer",type:"warning",children:[(0,o.jsxs)(n.p,{children:["There are a lot of strategies and advice for testing React components. Some of the things highlighted\nin this section might not make sense in the context of some of those strategies, or could even\nbe considered ",(0,o.jsx)(n.em,{children:"bad practice"}),"."]}),(0,o.jsx)(n.p,{children:"However, this section is inspired by the development of an actual application where applying the\ndescribed strategies tremendously helped us increase the quality of our tests, as well as the speed\nat which we could write them."})]}),"\n",(0,o.jsx)(n.h2,{id:"rationale",children:"Rationale"}),"\n",(0,o.jsx)(n.p,{children:"When testing components, we often learn to write tests that emulate the way a user would interact with the component.\nWhile this is perfectly sound advice, those end up being more integration tests than unit testing, since we're\nmixing logic and UI tests in one suite."}),"\n",(0,o.jsx)(n.p,{children:"For complex components such as forms, this also brings a lot of complexity in tests, or even duplication: to test various\nform submit scenarios for instance, we need to run steps to bring the form to a desired state first. This can get out of\nhand fairly quickly."}),"\n",(0,o.jsx)(n.p,{children:"This can be helped by splitting the form into smaller components of course, where the submit button or form wrapper would\nreceive the form state as props; or it can be improved a bit by extracting the logic into a custom hook, which can get\ntested in isolation. But this only delays the problem, as testing the final component will still be dependent on the\nlogic and the internal state from the hook."}),"\n",(0,o.jsxs)(n.p,{children:["With ",(0,o.jsx)(n.code,{children:"ModularComponent"}),", all this fades away thanks to ",(0,o.jsx)(n.strong,{children:"component stage isolation and mocking"}),". Each stage can easily\nbe isolated from the rest of the pipeline by using a dedicated method: the ",(0,o.jsx)(n.code,{children:"stage()"})," method."]}),"\n",(0,o.jsx)(n.p,{children:"In this document, we'll look at a simple login form component, looking like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\nimport { ModularComponent } from '@modular-component/core'\n\nconst LoginForm = ModularComponent()\n  .withRouter()\n  .withServices(['userSession'])\n  .withLocale('components.login-form')\n  .withLifecycle(({ services, router }) => {\n    const [email, setEmail] = useState('')\n    const [password, setPassword] = useState('')\n    const [error, setError] = useState('')\n    \n    const valid = !!email && !!password\n    \n    const handleChange = (field: 'email' | 'password') => {\n      const setter = { email: setEmail, password: setPassword }[field]\n      return (e: { currentTarget: { value: string } }) => {\n        setter(e.currentTarget.value)\n      }\n    }\n    \n    const handleSubmit = async () => {\n      if (!valid) {\n        setError('all-fields-are-required')\n        return\n      }\n      \n      try {\n        await services.userSession.login(email, password)\n        router.navigate('/profile')\n      } catch (err: { code: string }) {\n        setError(err.code)\n      }\n    }\n    \n    return {\n      email,\n      password,\n      error,\n      handleEmailChange: handleChange('email'),\n      handlePasswordChange: handleChange('password'),\n      handleSubmit\n    }\n  })\n  .withRender(({ lifecycle, locale }) => (\n    <form onSubmit={lifecycle.handleSubmit}>\n      <input \n        placeholder={locale('placeholders.email')} \n        type=\"text\" \n        value={lifecycle.email} \n        onChange={lifecycle.handleEmailChange} \n      />\n      <input\n        placeholder={locale('placeholders.password')}\n        type=\"password\" \n        value={lifecycle.password}\n        onChange={lifecycle.handlePasswordChange}\n      />\n      { !!lifecycle.error && <span>{locale(lifecycle.error) || locale('unknown-error')}</span> }\n      <button type=\"submit\">{locale('submit')}</button>\n    </form>\n  ))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"withRouter()"})," and ",(0,o.jsx)(n.code,{children:"withServices()"})," are imaginary custom stages that inject the routing mechanism and our backend\nservices into the argument map. ",(0,o.jsx)(n.code,{children:"withLocale()"})," is a localization stage that turns localization codes into localized strings."]}),"\n",(0,o.jsx)(n.p,{children:"In our tests, we want to make sure of a few things:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Given an incorrect state of the form, submitting should not call the backend service and raise an error"}),"\n",(0,o.jsx)(n.li,{children:"Given a correct state of the form, submitting should call the backend service"}),"\n",(0,o.jsxs)(n.li,{children:["Upon success of the backend call, a navigation event to ",(0,o.jsx)(n.code,{children:"/profile"})," is triggered"]}),"\n",(0,o.jsx)(n.li,{children:"Upon failure of the backend call, an error is raised"}),"\n",(0,o.jsx)(n.li,{children:"Submitting the HTML form calls our submit routine"}),"\n",(0,o.jsx)(n.li,{children:"Our HTML form elements are linked to our state"}),"\n",(0,o.jsx)(n.li,{children:"The correct messages are read from our localization system"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["The first four items are ",(0,o.jsx)(n.em,{children:"logic tests"}),", and thanks to our modular architecture, are the sole responsibility of\nthe ",(0,o.jsx)(n.strong,{children:"lifecycle stage"}),". The last three are ",(0,o.jsx)(n.em,{children:"UI tests"}),", and are the responsibility of the ",(0,o.jsx)(n.strong,{children:"render stage"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Now let's see how ",(0,o.jsx)(n.code,{children:"ModularComponent"})," helps us test each point easily."]}),"\n",(0,o.jsxs)(n.admonition,{type:"note",children:[(0,o.jsx)(n.p,{children:"This guide uses a made-up mock library for mocking functions, with a simplified API\nfor readability's sake."}),(0,o.jsx)(n.p,{children:"It also uses a made-up rendering API for testing React components."}),(0,o.jsx)(n.p,{children:"In real life, you would adapt those snippets to your testing APIs of choice."})]}),"\n",(0,o.jsx)(n.h2,{id:"testing-lifecycle-in-isolation",children:"Testing lifecycle in isolation"}),"\n",(0,o.jsxs)(n.p,{children:["We will write our tests stage by stage, from top to bottom. In our case only two stages contain custom logic: the ",(0,o.jsx)(n.code,{children:"lifecycle"}),"\nand ",(0,o.jsx)(n.code,{children:"render"})," stages."]}),"\n",(0,o.jsx)(n.p,{children:"The first part is testing the lifecycle. First, let's take a look at the upstream stages consumed by the lifecycle:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"  // Depends on services \ud83d\udc47...\n  .withLifecycle(({ services, router }) => ...\n  // ... and on a routing system \ud83d\udc46\n"})}),"\n",(0,o.jsx)(n.p,{children:"As we can see, our lifecycle depends on our backend services, and our routing system. Thankfully, both of those stages\nare already validated in their own dedicated test suites, so the component does not need to worry about them. We can\neasily mock those away:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const mocks = {\n  router: {\n    navigate: mock.fn()\n  },\n  services: {\n    userSession: {\n      login: mock.fn()\n    }\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now that we've prepared the mocks for the arguments consumed by our stage, we can isolate our stage function\nthrough the dedicated ",(0,o.jsx)(n.code,{children:"stage()"})," method:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const mocks = {\n  // ...\n}\n\nconst useLifecycle = LoginForm.stage('lifecycle')\n"})}),"\n",(0,o.jsx)(n.p,{children:"The generated hook takes as parameter a partial representation of arguments map, allowing you to only pass the upstream stages you know\nto be relevant. We can easily pass it our mocks we generated earlier."}),"\n",(0,o.jsxs)(n.p,{children:["We therefore get a ",(0,o.jsx)(n.code,{children:"useLifecycle"})," hook that can be tested in isolation, just as if we'd written\nit as a separate function. We can now test it out with our preferred hook testing library. Here is how things could look:"]}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Lifecycle tests"}),(0,o.jsx)("p",{children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"it('should provide an updatable email field', () => {\n  // Arrange\n  const { result } = renderHook(() => useLifecycle(mocks))\n  \n  // Assert initial state\n  expect(result.current.email).toEqual('')\n  \n  // Act\n  result.current.handleEmailChange({ currentTarget: { value: 'test@mail.com'} })\n  \n  // Assert\n  expect(result.current.email).toEqual('test@mail.com')\n})\n\nit('should provide an updatable password field', () => {\n  // Arrange\n  const { result } = renderHook(() => useLifecycle(mocks))\n\n  // Assert initial state\n  expect(result.current.password).toEqual('')\n\n  // Act\n  result.current.handlePasswordChange({ currentTarget: { value: 'S3curePassw0rd'} })\n\n  // Assert\n  expect(result.current.password).toEqual('S3curePassw0rd')\n})\n\nit('should not submit if form fields are empty, and raise an error', async () => {\n  // Arrange\n  const { login } = mocks.services.userSession\n  login.reset()\n  \n  const { result } = renderHook(() => useLifecycle(mocks))\n  \n  // Assert initial state\n  expect(login).not.toHaveBeenCalled()\n  expect(result.current.error).toEqual('')\n  \n  // Act\n  await result.current.handleSubmit()\n  \n  // Assert\n  expect(login).not.toHaveBeenCalled()\n  expect(result.current.error).toEqual('all-fields-are-required')\n})\n\nit('should submit if form fields are set, and navigate upon success', async () => {\n  // Arrange\n  const { login } = mocks.services.userSession\n  login.reset()\n  const { navigate } = mocks.router\n  navigate.reset()\n\n  const { result } = renderHook(() => useLifecycle(mocks))\n\n  // Assert initial state\n  expect(login).not.toHaveBeenCalled()\n  expect(navigate).not.toHaveBeenCalled()\n  expect(result.current.error).toEqual('')\n\n  // Act\n  result.current.handleEmailChange({ currentTarget: { value: 'test@mail.com'} })\n  result.current.handlePasswordChange({ currentTarget: { value: 'S3curePassw0rd'} })\n  \n  await result.current.handleSubmit()\n\n  // Assert\n  expect(login).toHaveBeenCalled()\n  expect(login).toHaveBeenCalledWith('test@mail.com', 'S3curePassw0rd')\n  \n  expect(navigate).toHaveBeenCalled()\n  expect(navigate).toHaveBeenCalledWith('/profile')\n\n  expect(result.current.error).toEqual('')\n})\n\nit('should submit if form fields are set, and raise an error upon failure', async () => {\n  // Arrange\n  const { login } = mocks.services.userSession\n  login.reset()\n  login.rejects({ code: 'invalid-credentials' })\n  const { navigate } = mocks.router\n  navigate.reset()\n\n  const { result } = renderHook(() => useLifecycle(mocks))\n\n  // Assert initial state\n  expect(login).not.toHaveBeenCalled()\n  expect(navigate).not.toHaveBeenCalled()\n  expect(result.current.error).toEqual('')\n\n  // Act\n  result.current.handleEmailChange({ currentTarget: { value: 'test@mail.com'} })\n  result.current.handlePasswordChange({ currentTarget: { value: 'S3curePassw0rd'} })\n  \n  await result.current.handleSubmit()\n\n  // Assert\n  expect(login).toHaveBeenCalled()\n  expect(login).toHaveBeenCalledWith('test@mail.com', 'S3curePassw0rd')\n\n  expect(navigate).not.toHaveBeenCalled()\n\n  expect(result.current.error).toEqual('invalid-credentials')\n})\n"})})})]}),"\n",(0,o.jsx)(n.p,{children:"And just like this, we tested all our scenarios for logic, while achieving 100% code coverage."}),"\n",(0,o.jsx)(n.h2,{id:"testing-the-render-phase-with-controlled-lifecycle",children:"Testing the render phase with controlled lifecycle"}),"\n",(0,o.jsxs)(n.p,{children:["With our lifecycle behavior tested for all our scenarios, we can move on to testing our render phase.\nHere, we basically want to check that we correctly draw all required elements (a form, two inputs, a button),\n",(0,o.jsx)(n.em,{children:"and that interacting with them calls the correct functions in our lifecycle"}),". Behavior of the lifecycle itself\nis not needed in those tests, as we've already validated it."]}),"\n",(0,o.jsxs)(n.p,{children:["But we also want to see how our render ",(0,o.jsx)(n.em,{children:"adapts"})," to values returned by the lifecycle. Fortunately, this can\neasily be done by ",(0,o.jsx)(n.em,{children:"mocking the stages required by the render"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Once again, let's look at what stages our render phase requires:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"  // Use the lifecycle \ud83d\udc47...\n  .withRender(({ lifecycle, locale }) => ...\n  // ... and a locale system  \ud83d\udc46\n"})}),"\n",(0,o.jsx)(n.p,{children:"In order to isolate our render, we can mock the lifecycle and locale stages."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const mocks = {\n  locale: mock.fn().implementation((key: string) => key),\n  lifecycle: {\n    email: 'test@mail.com',\n    password: 'S3curePassw0rd',\n    error: '',\n    handleEmailChange: mock.fn(),\n    handlePasswordChange: mock.fn(),\n    handleSubmit: mock.fn()\n  }\n}\n\nconst Component = LoginForm.stage('render')\n"})}),"\n",(0,o.jsx)(n.p,{children:"With this, we get our render stage isolated from its upstream stages, with full control on values passed down through\nthe argument map. We mocked the lifecycle with default values, and the locale with an identity function for now."}),"\n",(0,o.jsx)(n.p,{children:"Our render tests could look like the following:"}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Render tests"}),(0,o.jsx)("p",{children:(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"it('should render an email input controlled by lifecycle', () => {\n  // Arrange\n  const onChange = mocks.lifecycle.handleEmailChange\n  onChange.reset()\n\n  const { getByPlaceholder } = render(<Component {...mocks} />)\n  \n  // Assert initial state\n  const emailInput = getByPlaceholder('placeholders.email')\n  \n  expect(emailInput).toExist()\n  expect(emailInput.value).toEqual('test@mail.com')\n  \n  expect(onChange).not.toHaveBeenCalled()\n  \n  // Act\n  userEvent.input(emailInput, 'new@mail.com')\n  \n  // Assert\n  expect(onChange).toHaveBeenCalled()\n  expect(onChange).toHaveBeenCalledWith({ currentTarget: { value: 'new@mail.com'} })\n})\n\nit('should render a password input controlled by lifecycle', () => {\n  // Arrange\n  const onChange = mocks.lifecycle.handlePasswordChange\n  onChange.reset()\n\n  const { getByPlaceholder } = render(<Component {...mocks} />)\n\n  // Assert initial state\n  const passwordInput = getByPlaceholder('placeholders.password')\n\n  expect(passwordInput).toExist()\n  expect(passwordInput.value).toEqual('S3curePassw0rd')\n\n  expect(onChange).not.toHaveBeenCalled()\n\n  // Act\n  userEvent.input(passwordInput, 'insecure-password')\n\n  // Assert\n  expect(onChange).toHaveBeenCalled()\n  expect(onChange).toHaveBeenCalledWith({ currentTarget: { value: 'insecure-password'} })\n})\n\nit('should call the submit handler on form submit', () => {\n  // Arrange\n  const onSubmit = mocks.lifecycle.handleSubmit\n  onSubmit.reset()\n\n  const { getByRole } = render(<Component {...mocks} />)\n\n  // Assert initial state\n  const submitButton = getByRole('button')\n\n  expect(submitButton).toExist()\n  expect(submitButton.innerText).toEqual('submit')\n\n  expect(onSubmit).not.toHaveBeenCalled()\n\n  // Act\n  userEvent.click(submitButton)\n\n  // Assert\n  expect(onSubmit).toHaveBeenCalled()\n})\n\nit('should translate known error codes', () => {\n  // Arrange\n  mocks.lifecycle.error = 'a-known-error'\n  \n  const { getByText, rerender } = render(<Component {...mocks} />)\n  \n  // Assert\n  expect(getByText('a-known-error')).toExist()\n\n  // Re-arrange\n  mocks.lifecycle.error = 'another-known-error'\n  rerender(<Component {...mocks} />)\n  \n  // Assert\n  expect(getByText('a-known-error')).not.toExist()\n  expect(getByText('another-known-error')).toExist()\n})\n\nit('should render a default value for unknown errors', () => {\n  // Arrange\n  mocks.locale.implementation((key: string) => key === 'an-unknown-error-that-will-get-ignored' ? null : key)\n  mocks.lifecycle.error = 'an-unknown-error-that-will-get-ignored'\n\n  const { getByText } = render(<Component {...mocks} />)\n\n  // Assert\n  expect(getByText('an-unknown-error-that-will-get-ignored')).not.toExist()\n  expect(getByText('unknown-error')).toExist()\n})\n\nit('should not render errors at all when it\\'s empty', () => {\n  // Arrange\n  mocks.locale.implementation((key: string) => key)\n  mocks.lifecycle.error = ''\n\n  const { getByText } = render(<Component {...mocks} />)\n  \n  // Assert\n  expect(getByText('unknown-error')).not.toExist()\n})\n"})})})]}),"\n",(0,o.jsx)(n.p,{children:"And with this, we finished covering all the render scenarios that we wanted. Both our lifecycle stage and render stage\nare now covered and tested, without having one leak into the other, keeping our tests unitary."}),"\n",(0,o.jsx)(n.h2,{id:"abstracting-sub-components-in-composed-components",children:"Abstracting sub-components in composed components"}),"\n",(0,o.jsx)(n.p,{children:"Our simple component only uses intrinsic HTML elements, but often our components are composed of other components too."}),"\n",(0,o.jsxs)(n.p,{children:["Let's imagine that we want to replace the inputs in our example with custom dedicated ",(0,o.jsx)(n.code,{children:"Input"}),"s components:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"<form onSubmit={lifecycle.handleSubmit}>\n  <EmailInput\n    placeholder={locale('placeholders.email')} \n    value={lifecycle.email} \n    onChange={lifecycle.handleEmailChange} \n  />\n  <PasswordInput\n    placeholder={locale('placeholders.password')}\n    value={lifecycle.password}\n    onChange={lifecycle.handlePasswordChange}\n  />\n  { !!lifecycle.error && <span>{locale(lifecycle.error) || locale('unknown-error')}</span> }\n  <button type=\"submit\">{locale('submit')}</button>\n</form>\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now it's possible that those components have some internals that make it difficult to test our form without knowing\nthe internal behavior of the components. Our tests would become tightly coupled, and we don't want that.\nHere for instance, we cannot reliably know how to select the actual HTML input or to trigger the ",(0,o.jsx)(n.code,{children:"onChange"})," callback.\nBut what if we could select the ",(0,o.jsx)(n.em,{children:"component instance"})," instead, and manually trigger callback props?"]}),"\n",(0,o.jsx)(n.p,{children:"For this use-case, we could use a components stage to easily allow mocking our sub-components without relying on module\nmocking. For that, let's update our component:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { useState } from 'react'\nimport { ModularComponent } from '@modular-component/core'\n\n// highlight-next-line\nimport { EmailInput, PasswordInput } from './shared-inputs'\n\nconst LoginForm = ModularComponent()\n  .withRouter()\n  .withServices(['userSession'])\n  .withLocale('components.login-form')\n  // highlight-next-line\n  .withComponents({ EmailInput, PasswordInput })\n  .withLifecycle(({ services, router }) => {\n    // ... omitted for brevity\n  })\n  // highlight-next-line\n  .withRender(({ lifecycle, locale, components }) => (\n    <form onSubmit={lifecycle.handleSubmit}>\n      // highlight-next-line\n      <components.EmailInput \n        placeholder={locale('placeholders.email')} \n        value={lifecycle.email} \n        onChange={lifecycle.handleEmailChange} \n      />\n      // highlight-next-line\n      <components.PasswordInput\n        placeholder={locale('placeholders.password')}\n        value={lifecycle.password}\n        onChange={lifecycle.handlePasswordChange}\n      />\n      { !!lifecycle.error && <span>{locale(lifecycle.error) || locale('unknown-error')}</span> }\n      <button type=\"submit\">{locale('submit')}</button>\n    </form>\n  ))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Notice how in the render, we use the components injected by the ",(0,o.jsx)(n.code,{children:"withComponents()"})," stage. Thanks to that, it becomes\neasy to replace them by dummy implementations in our tests."]}),"\n",(0,o.jsx)(n.p,{children:"For instance, we could reduce them to standard inputs:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"const mocks = {\n  ...,\n  components: { EmailInput: 'input', PasswordInput: 'input' }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This way, the tests we added previously will keep working, but that only works if the props are compatible."}),"\n",(0,o.jsx)(n.p,{children:"A better alternative is to use mocks for components instead:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:'const mocks = {\n  ...,\n  components: {\n    EmailInput: mock.fn().returns(<div data-testid="email-input" />),\n    PasswordInput: mock.fn().returns(<div data-testid="password-input" />)\n  }\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"Thanks to this, we can now use those mocks in our tests to validate the expected props are passed down:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"it('should render an email input controlled by lifecycle', () => {\n  // Arrange\n  const emailInput = mocks.components.EmailInput\n\n  const { getByTestId } = render(<Component {...mocks} />)\n  \n  // Assert\n  expect(getByTestId('email-input')).toExist()\n  expect(emailInput).toHaveBeenCalled()\n  expect(emailInput).toHaveBeenCalledWith({\n    placeholder: 'placeholders.email',\n    value: mocks.lifecycle.email,\n    onChange: mocks.lifecycle.handleEmailChange\n  })\n})\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(6540);const o={},r=s.createContext(o);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
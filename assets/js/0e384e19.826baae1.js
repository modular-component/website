"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),c=p(n),m=o,h=c["".concat(s,".").concat(m)]||c[m]||d[m]||l;return n?a.createElement(h,r(r({ref:t},u),{},{components:n})):a.createElement(h,r({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,r=new Array(l);r[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var p=2;p<l;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9881:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const l={sidebar_position:1},r="ModularComponent",i={unversionedId:"intro",id:"intro",title:"ModularComponent",description:"\ud83c\udf5e.with(\ud83c\udf45).with(\ud83e\uddc0) = \ud83e\udd6a",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/docs/intro",draft:!1,editUrl:"https://github.com/modular-component/website/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Writing Components",permalink:"/docs/usage/writing-components"}},s={},p=[{value:"What are Modular Components",id:"what-are-modular-components",level:2},{value:"Installation",id:"installation",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"The factory pipeline",id:"the-factory-pipeline",level:3},{value:"Pipeline stages",id:"pipeline-stages",level:4},{value:"Adding stages",id:"adding-stages",level:4},{value:"Generating hooks",id:"generating-hooks",level:3},{value:"Other methods",id:"other-methods",level:3},{value:"Isolating a stage",id:"isolating-a-stage",level:4},{value:"Setting the component&#39;s <code>displayName</code>",id:"setting-the-components-displayname",level:4}],u={toc:p};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"modularcomponent"},"ModularComponent"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"\ud83c\udf5e.with(\ud83c\udf45).with(\ud83e\uddc0) = \ud83e\udd6a")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Delightfully organized and deeply testable React Components")),(0,o.kt)("h2",{id:"what-are-modular-components"},"What are Modular Components"),(0,o.kt)("p",null,"Modular Components are React components built through a modular factory, allowing the\naddition of functionality as needed as the component is built."),(0,o.kt)("p",null,"The modular factory approach is built on top of React hooks, and offers out-of-the-box\ncomposition for building and stub injections for testing."),(0,o.kt)("p",null,"It offers best-in-class DX through strong typing and easy separation of concern, and is\ninfinitely extensible thanks to its built-in modular nature."),(0,o.kt)("p",null,'You can think of it as "higher-order hooks", without the awkward chaining of methods\nthanks to the factory pattern.'),(0,o.kt)("h2",{id:"installation"},"Installation"),(0,o.kt)("p",null,"At it simplest, you will need the ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/core")," package to get started with ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent"),"."),(0,o.kt)("p",null,"However, the core module alone does not bring any component capability - it needs plugins,\nor extensions, to start shining \u2728 !"),(0,o.kt)("p",null,"We provide a sensible set of default capabilities through the ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/default")," package.\nIt is highly recommended to install both for getting started."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"yarn add @modular-component/core @modular-component/default\n")),(0,o.kt)("p",null,"You can then build your components using the ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," factory exported from ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/core"),",\nand the default set of stages exported from ",(0,o.kt)("inlineCode",{parentName:"p"},"@modular-component/default"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ModularComponent } from '@modular-component/core'\nimport * as Stage from '@modular-component/default'\n\nconst MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  .with(Stage.defaultProps({ someFlag: false }))\n  .with(Stage.lifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  }))\n  .with(Stage.render(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  )))\n")),(0,o.kt)("h2",{id:"how-it-works"},"How it works"),(0,o.kt)("h3",{id:"the-factory-pipeline"},"The factory pipeline"),(0,o.kt)("h4",{id:"pipeline-stages"},"Pipeline stages"),(0,o.kt)("p",null,"The main concept behind the ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," approach is the factory pipeline."),(0,o.kt)("p",null,"At its core, a ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," is a set of ordered ",(0,o.kt)("strong",{parentName:"p"},"stages"),", each of which populates\na specific ",(0,o.kt)("strong",{parentName:"p"},"argument")," in a shared object, which gets passed from stage to stage."),(0,o.kt)("p",null,"The last stage (the ",(0,o.kt)("strong",{parentName:"p"},"render")," stage) has therefore access\nto data computed by every previous stage in the pipeline."),(0,o.kt)("p",null,"This for instance allows separating any stateful lifecycle computation in a dedicated\nstage, and keep the render stage for its main purpose: laying down the markup through JSX."),(0,o.kt)("p",null,'Here is the "getting started" example, complete with comments explaining\nthe pipeline system:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ModularComponent } from '@modular-component/core'\nimport * as Stage from '@modular-component/default'\n\nconst MyFirstModularComponent = ModularComponent<{\n  someFlag?: boolean\n  someLabel: string\n  someValue: number\n}>()\n  // .with(defaultProps) modifies the `props` argument to mark\n  // provided props as NonNullable. Here, `someFlag` will be\n  // a `boolean` for all downstream stages, instead of `boolean | undefined`\n  // as it originally was\n  .with(Stage.defaultProps({ someFlag: false }))\n  // .with(lifecycle) receives the modified props from .with(defaultProps)\n  // It then uses React hooks to construct our component's internal state\n  .with(Stage.lifecycle(({ props }) => {\n    const [someState, setSomeState] = useState(0)\n\n    return { someState }\n  }))\n  // Finally, .with(render) receives both the up-to-date props and the new\n  // lifecycle argument generated by the .with(lifecycle) stage\n  .with(render(({ props, lifecycle }) => (\n    <>\n      <h2>\n        {props.someLabel}: {props.someValue}\n      </h2>\n      <p>Value from state: {lifecycle.someState}</p>\n      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>\n    </>\n  )))\n")),(0,o.kt)("h4",{id:"adding-stages"},"Adding stages"),(0,o.kt)("p",null,"You can keep on chaining ",(0,o.kt)("inlineCode",{parentName:"p"},".with")," calls as much as you want to add more stages. However, a given field can only be set once:\ncalling ",(0,o.kt)("inlineCode",{parentName:"p"},".with")," again with a different payload for the same field will replace the initial stage set for that field."),(0,o.kt)("p",null,"Internally, a ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," keeps an array of ordered stages. Calling the ",(0,o.kt)("inlineCode",{parentName:"p"},".with"),"\nmethod will either append a new stage to the array, or edit an already existing value."),(0,o.kt)("p",null,"When using TypeScript, the compiler will tell you if a subsequent call to ",(0,o.kt)("inlineCode",{parentName:"p"},".with")," with an existing field causes\na conflict with the previous value, to ensure coherence between stages."),(0,o.kt)("admonition",{title:"TypeScript: Forcing a new value on a field",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"If you are using TypeScript and want to override a field completely without backwards compatibility with its previous\nvalue (for instance if you know you will be editing all stages depending on the field too), you can replace ",(0,o.kt)("inlineCode",{parentName:"p"},".with"),"\nwith ",(0,o.kt)("inlineCode",{parentName:"p"},".force"),", which does the same internally but bypasses the type checking.")),(0,o.kt)("h3",{id:"generating-hooks"},"Generating hooks"),(0,o.kt)("p",null,"By default, if a ",(0,o.kt)("strong",{parentName:"p"},"render")," stage is not provided in your pipeline, ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," will inject one on your behalf\nthat returns ",(0,o.kt)("inlineCode",{parentName:"p"},"null"),", so that your component stays renderable."),(0,o.kt)("p",null,"But you can also opt to skip the render step entirely, turning your ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," into a hook."),(0,o.kt)("p",null,"Simply append ",(0,o.kt)("inlineCode",{parentName:"p"},"use()")," at the end of your chain to enable this feature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const useModularHook = ModularComponent()\n  .with(Stage.lifecycle(() => {\n    const [enabled, setEnabled] = React.useState(false)\n    const toggleOn = React.useCallback(() => setEnabled(true), [])\n    const toggleOff = React.useCallback(() => setEnabled(false), [])\n    return { enabled, toggleOn, toggleOff }\n  }))\n  .use()\n\n// ...\nconst { lifecycle } = useModularHook()\n\nlifecycle.toggleOn()\nlifecycle.enabled\n")),(0,o.kt)("p",null,"You can also pass the name of an argument field to the ",(0,o.kt)("inlineCode",{parentName:"p"},"use()")," method to isolate this specific stage.\nStages downstream to the stage generating the argument will be skipped, and the return value will be\nscoped to the selected field:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const useIsolatedStage = ModularComponent()\n  .with(Stage.lifecycle(() => {\n    const [enabled, setEnabled] = React.useState(false)\n    const toggleOn = React.useCallback(() => setEnabled(true), [])\n    const toggleOff = React.useCallback(() => setEnabled(false), [])\n    return { enabled, toggleOn, toggleOff }\n  }))\n  .use('lifecycle')\n\n// ...\nconst { toggleOn, toggleOff, enabled } = useIsolatedStage()\n")),(0,o.kt)("h3",{id:"other-methods"},"Other methods"),(0,o.kt)("h4",{id:"isolating-a-stage"},"Isolating a stage"),(0,o.kt)("p",null,"For testing purposes, you might want to extract a stage function to be able to unit-test it in isolation. You can\nuse the ",(0,o.kt)("inlineCode",{parentName:"p"},"stage()")," method to achieve just that."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"stage()")," takes things a step further than ",(0,o.kt)("inlineCode",{parentName:"p"},"use()"),", and should really only be used for testing purposes. It always takes\na field name to isolate, and returns a hook that takes the arguments map as parameter rather than the component props."),(0,o.kt)("p",null,"When using ",(0,o.kt)("inlineCode",{parentName:"p"},"stage()"),", you are responsible for providing the relevant arguments expected by your stage function to work.\nIts only use-case is for testing purposes where you want to finely control each input and check the output."),(0,o.kt)("h4",{id:"setting-the-components-displayname"},"Setting the component's ",(0,o.kt)("inlineCode",{parentName:"h4"},"displayName")),(0,o.kt)("p",null,"Since the actual component function is created inside the factory, React cannot infer its display name from your\nvariable name. If you want to set a display name for debugging purposes, you have several ways:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Simply set the ",(0,o.kt)("inlineCode",{parentName:"p"},"displayName")," property on your generated component, like any other React component:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyComponent = ModularComponent()\n .with(...)\n\nMyComponent.displayName = 'MyComponent'\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Pass your display name as first and only parameter to the initial ",(0,o.kt)("inlineCode",{parentName:"p"},"ModularComponent")," call:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyComponent = ModularComponent('MyComponent')\n .with(...)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Call ",(0,o.kt)("inlineCode",{parentName:"p"},"withDisplayName")," somewhere in your pipeline:"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"const MyComponent = ModularComponent()\n .withDisplayName('MyComponent')\n .with(...)\n")))))}d.isMDXComponent=!0}}]);
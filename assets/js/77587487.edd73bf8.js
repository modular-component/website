"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8232],{1811:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"reference","title":"Reference","description":"Here is the complete type reference of every export from @modular-component/core and @modular-component/core/extend.","source":"@site/docs/reference.md","sourceDirName":".","slug":"/reference","permalink":"/docs/reference","draft":false,"unlisted":false,"editUrl":"https://github.com/modular-component/website/docs/reference.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Reference"},"sidebar":"tutorialSidebar","previous":{"title":"@modular-component/with-fragment","permalink":"/docs/extensions/official/with-fragment"},"next":{"title":"LLM Prompt Kit","permalink":"/docs/llm-prompt-kit"}}');var o=t(4848),s=t(8453);const i={sidebar_position:5,title:"Reference"},d=void 0,a={},l=[{value:"<code>@modular-component/core</code>",id:"modular-componentcore",level:2},{value:"Type: <code>ModularComponent&lt;Context&gt;</code>",id:"type-modularcomponentcontext",level:3},{value:"When to use it",id:"when-to-use-it",level:4},{value:"Parameters",id:"parameters",level:4},{value:"Type: <code>ModularContext</code>",id:"type-modularcontext",level:3},{value:"When to use it",id:"when-to-use-it-1",level:4},{value:"Type: <code>WithRender&lt;Context&gt;</code>",id:"type-withrendercontext",level:3},{value:"When to use it",id:"when-to-use-it-2",level:4},{value:"Parameters",id:"parameters-1",level:4},{value:"Function: <code>ModularComponent</code>",id:"function-modularcomponent",level:3},{value:"When to use it",id:"when-to-use-it-3",level:4},{value:"Function parameters",id:"function-parameters",level:4},{value:"Type parameters",id:"type-parameters",level:4},{value:"Function: <code>render</code>",id:"function-render",level:3},{value:"When to use it",id:"when-to-use-it-4",level:4},{value:"Function parameters",id:"function-parameters-1",level:4},{value:"Type parameters",id:"type-parameters-1",level:4},{value:"<code>@modular-component/core/extend</code>",id:"modular-componentcoreextend",level:2},{value:"Type: <code>AppendStage&lt;Context, Field, Type&gt;</code>",id:"type-appendstagecontext-field-type",level:3},{value:"When to use it",id:"when-to-use-it-5",level:4},{value:"Parameters",id:"parameters-2",level:4},{value:"Type: <code>GetArgsFor&lt;Context, Field&gt;</code>",id:"type-getargsforcontext-field",level:3},{value:"When to use it",id:"when-to-use-it-6",level:4},{value:"Parameters",id:"parameters-3",level:4},{value:"Type: <code>GetConstraintFor&lt;Context, Field, Default&gt;</code>",id:"type-getconstraintforcontext-field-default",level:3},{value:"When to use it",id:"when-to-use-it-7",level:4},{value:"Parameters",id:"parameters-4",level:4},{value:"Type: <code>GetValueGetterFor&lt;Context, Field, Type&gt;</code>",id:"type-getvaluegetterforcontext-field-type",level:3},{value:"When to use it",id:"when-to-use-it-8",level:4},{value:"Parameters",id:"parameters-5",level:4},{value:"Type: <code>ModularContext</code>",id:"type-modularcontext-1",level:3},{value:"Type: <code>StageParams&lt;Fn&gt;</code>",id:"type-stageparamsfn",level:3},{value:"When to use it",id:"when-to-use-it-9",level:4},{value:"Type: <code>StageReturn&lt;Fn&gt;</code>",id:"type-stagereturnfn",level:3},{value:"When to use it",id:"when-to-use-it-10",level:4},{value:"Function: <code>addTo</code>",id:"function-addto",level:3},{value:"When to use it",id:"when-to-use-it-11",level:4},{value:"Type parameters",id:"type-parameters-2",level:4},{value:"Function: <code>wrap</code>",id:"function-wrap",level:3},{value:"When to use it",id:"when-to-use-it-12",level:4},{value:"Function parameters",id:"function-parameters-2",level:4},{value:"Type parameters",id:"type-parameters-3",level:4}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components},{Details:t}=n;return t||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Here is the complete type reference of every export from ",(0,o.jsx)(n.code,{children:"@modular-component/core"})," and ",(0,o.jsx)(n.code,{children:"@modular-component/core/extend"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"modular-componentcore",children:(0,o.jsx)(n.code,{children:"@modular-component/core"})}),"\n",(0,o.jsxs)(n.h3,{id:"type-modularcomponentcontext",children:["Type: ",(0,o.jsx)(n.code,{children:"ModularComponent<Context>"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ModularComponent<Context>"})," type is the type returned by calling the ",(0,o.jsx)(n.a,{href:"#function-modularcomponent",children:(0,o.jsx)(n.code,{children:"ModularComponent"})})," factory function,\nor any of its factory methods. It takes a single generic type parameter, ",(0,o.jsx)(n.code,{children:"Context"}),", of type ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})}),", describing\nthe combined state of all stages that have been assigned to it."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["You should almost never need to use it manually. It is used internally as the return type of ",(0,o.jsx)(n.a,{href:"#function-modularcomponent",children:(0,o.jsx)(n.code,{children:"ModularComponent"})}),"."]}),(0,o.jsx)(n.h4,{id:"parameters",children:"Parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Context"}),": ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})," - description of all stages added to the Modular Component, including props,\narguments, constraints..."]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { FunctionComponent, ForwardRefRenderFunction, PropsWithChildren} from 'react'\nimport {\n  ModularComponentStages,\n  ModularContext,\n} from '@modular-component/stages'\n\ntype FunctionComponentOrRefRenderFunction<Props, Ref> = [Ref] extends [never]\n  ? FunctionComponent<PropsWithChildren<Props>>\n  : ForwardRefRenderFunction<Ref, Props>\n\ntype MapToForce<Stages> = {\n  [key in keyof Stages as key extends `with${infer K}`\n    ? `force${K}`\n    : never]: Stages[key]\n}\n\ntype MapToStage<Stages> = Pick<\n  Stages,\n  {\n    [key in keyof Stages]: key extends `with${string}` ? key : never\n  }[keyof Stages]\n>\n\ntype MapToRaw<Stages> = {\n  [key in keyof Stages as key extends `with${infer K}`\n    ? Lowercase<K>\n    : never]: Stages[key]\n}\n\ntype Force<Context extends ModularContext> = Omit<Context, 'constraints'> & {\n  constraints: {}\n  _constraints: Context['constraints']\n}\n\nexport type ModularComponent<Context extends ModularContext> =\n  FunctionComponentOrRefRenderFunction<Context['props'], Context['ref']> &\n    MapToStage<ModularComponentStages<Context>> &\n    MapToForce<ModularComponentStages<Force<Context>>> & {\n      with<Field extends string, Type extends GetConstraintFor<Context, Field>>(\n        stage: (context?: Context) => {\n          field: Field\n          provide: (args: GetArgsFor<Context, Field>) => Type\n        },\n      ): ModularComponent<AppendStage<Context, Field, Type>>\n      force<Field extends string, Type>(\n        stage: (context?: Force<Context>) => {\n          field: Field\n          provide: (args: GetArgsFor<Context, Field>) => Type\n        },\n      ): ModularComponent<AppendStage<Context, Field, Type>>\n\n      use<Field extends keyof Context['arguments']>(\n        key: Field,\n      ): {} extends Context['arguments']['props']\n        ? () => Context['arguments'][Field]\n        : (\n            props: PropsWithChildren<Context['arguments']['props']>,\n          ) => Context['arguments'][Field]\n      use(): {} extends Context['props']\n        ? () => Context['arguments']\n        : (props: PropsWithChildren<Context['props']>) => Context['arguments']\n      stage<Field extends keyof Context['arguments'] & string>(\n        key: Field,\n      ): (\n        args: Partial<GetArgsFor<Context, Field>>,\n      ) => Context['arguments'][Field]\n      withDisplayName(displayName: string): ModularComponent<Context>\n    }\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"type-modularcontext",children:["Type: ",(0,o.jsx)(n.code,{children:"ModularContext"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ModularContext"})," type is the base type that all ",(0,o.jsx)(n.code,{children:"ModularComponent"}),"'s contexts will extend."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-1",children:"When to use it"}),(0,o.jsx)(n.p,{children:"In almost all cases, you should not care about what this type looks like, it is simply passed around by stage\nfunctions to compute the next context after running the stage."}),(0,o.jsx)(n.p,{children:"Instead, you should rely on the provided type helpers for extracting useful information from the context:"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#type-getargsforcontext-field",children:(0,o.jsx)(n.code,{children:"GetArgsFor"})})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#type-getconstraintforcontext-field-default",children:(0,o.jsx)(n.code,{children:"GetConstraintFor"})})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#type-getvaluegetterforcontext-field-type",children:(0,o.jsx)(n.code,{children:"GetValueGetterFor"})})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#type-stageparamsfn",children:(0,o.jsx)(n.code,{children:"StageParams"})})}),"\n",(0,o.jsx)(n.li,{children:(0,o.jsx)(n.a,{href:"#type-stagereturnfn",children:(0,o.jsx)(n.code,{children:"StageReturn"})})}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export type ModularContext = {\n  arguments: Record<string, any>\n  constraints: Record<string, any>\n  _constraints?: Record<string, any>\n  stages: Record<string, string>\n  props: any\n  ref: any\n}\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"type-withrendercontext",children:["Type: ",(0,o.jsx)(n.code,{children:"WithRender<Context>"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["Typing information for ",(0,o.jsx)(n.a,{href:"/docs/usage/writing-custom-stages#registering-the-stage",children:"registering"})," the ",(0,o.jsx)(n.a,{href:"#function-render",children:(0,o.jsx)(n.code,{children:"render"})})," stage."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-2",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["You can use ",(0,o.jsx)(n.code,{children:"WithRender<Context>"})," if you want to ",(0,o.jsx)(n.a,{href:"/docs/usage/writing-custom-stages#registering-the-stage",children:"manually register"}),"\nthe ",(0,o.jsx)(n.a,{href:"#function-render",children:(0,o.jsx)(n.code,{children:"render"})})," stage in your app."]}),(0,o.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Context"}),": ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})," - current context of the ModularComponent ",(0,o.jsx)(n.code,{children:"render"})," is called on. Provided either by\n",(0,o.jsx)(n.code,{children:"ModularComponent::with"}),", or through ",(0,o.jsx)(n.code,{children:"ModularComponentStages"})," type augmentation."]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { FunctionComponent } from 'react'\nimport { ModularContext, GetValueGetterFor, GetArgsFor, StageParams, StageReturn } from '@modular-component/core/extend'\n\nfunction render<Context extends ModularContext>(\n  useRender: GetValueGetterFor<Context, 'render', ReturnType<FunctionComponent>>\n): (_?: Context) => {\n  field: 'render'\n  provide: (args: GetArgsFor<Context, 'render'>) => ReturnType<FunctionComponent>\n}\n\nexport type WithRender<Context extends ModularContext> = (\n  ...args: StageParams<typeof render<Context>>\n) => StageReturn<typeof render<Context>>\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"function-modularcomponent",children:["Function: ",(0,o.jsx)(n.code,{children:"ModularComponent"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"ModularComponent"})," function creates a new ",(0,o.jsx)(n.code,{children:"ModularComponent"}),", which can then be extended by\nchaining stage methods."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-3",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"ModularComponent"})," to create a new ",(0,o.jsx)(n.code,{children:"ModularComponent"}),"."]}),(0,o.jsx)(n.h4,{id:"function-parameters",children:"Function parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"displayName?: string"}),": Optional ",(0,o.jsx)(n.code,{children:"displayName"})," parameter for setting the React debugging display name."]}),"\n"]}),(0,o.jsx)(n.h4,{id:"type-parameters",children:"Type parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Props"}),": Optional, sets the props accepted by the component,"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Ref"}),": Optional, sets the type of the forwarded ref. In cases where ",(0,o.jsx)(n.code,{children:"Ref"})," is set,\nit's your responsibility to wrap the ",(0,o.jsx)(n.code,{children:"ModularComponent"})," call inside ",(0,o.jsx)(n.code,{children:"React.forwardRef"}),"."]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { FunctionComponent } from 'react'\n\nexport function ModularComponent<Props extends {} = {}, Ref = never>(\n  displayName?: string,\n): ModularComponent<{\n  props: Props\n  ref: Ref\n  stages: {}\n  arguments: {\n    props: Props\n    ref: Ref\n    render: ReturnType<FunctionComponent>\n  }\n  constraints: {\n    props: Props\n    ref: Ref\n    render: ReturnType<FunctionComponent>\n  }\n}>\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"function-render",children:["Function: ",(0,o.jsx)(n.code,{children:"render"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["Stage function providing the default ",(0,o.jsx)(n.code,{children:"render"})," stage, accepting as single argument a function\nreceiving the consolidated stages arguments and returning a ",(0,o.jsx)(n.code,{children:"ReactNode"}),"."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-4",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use it in the ",(0,o.jsx)(n.code,{children:"ModularComponent::with"})," method to add a render stage; or use it with ",(0,o.jsx)(n.code,{children:"ModularComponent.register"}),"\nto register the ",(0,o.jsx)(n.code,{children:"ModularComponent::withRender"})," stage function for usage across your app."]}),(0,o.jsx)(n.h4,{id:"function-parameters-1",children:"Function parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useRender: GetValueGetterFor<Context, 'render', ReturnType<FunctionComponent>>"}),": either a React node, or a function\nreturning a React node. If a function is provided, it receives as only parameter the arguments map consolidated from\nall upstream stages."]}),"\n"]}),(0,o.jsx)(n.h4,{id:"type-parameters-1",children:"Type parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Context"}),": ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})," - current context of the ModularComponent ",(0,o.jsx)(n.code,{children:"render"})," is called on.\nInferred from either ",(0,o.jsx)(n.code,{children:"ModularComponent::with"})," or ",(0,o.jsx)(n.code,{children:"ModularComponent::withRender"})]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"import { FunctionComponent } from 'react'\nimport { GetValueGetterFor, GetArgsFor } from '@modular-component/core/extend'\n\nexport function render<Context extends ModularContext>(\n  useRender: GetValueGetterFor<Context, 'render', ReturnType<FunctionComponent>>\n): (_?: Context) => {\n  field: 'render'\n  provide: (args: GetArgsFor<Context, 'render'>) => ReturnType<FunctionComponent>\n}\n"})})]})]}),"\n",(0,o.jsx)(n.h2,{id:"modular-componentcoreextend",children:(0,o.jsx)(n.code,{children:"@modular-component/core/extend"})}),"\n",(0,o.jsxs)(n.h3,{id:"type-appendstagecontext-field-type",children:["Type: ",(0,o.jsx)(n.code,{children:"AppendStage<Context, Field, Type>"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["This type is mostly used internally in ",(0,o.jsx)(n.a,{href:"#type-stagereturnfn",children:(0,o.jsx)(n.code,{children:"StageReturn"})}),". It takes a ",(0,o.jsx)(n.code,{children:"ModularContext"}),"\nand appends a stage at the given ",(0,o.jsx)(n.code,{children:"Field"})," with the given ",(0,o.jsx)(n.code,{children:"Type"}),", returning a new context."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-5",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use this type when you need to create a new ",(0,o.jsx)(n.code,{children:"ModularContext"})," from a previous one.\nMostly use internally by ",(0,o.jsx)(n.a,{href:"#type-stagereturnfn",children:(0,o.jsx)(n.code,{children:"StageReturn"})}),", you should only need it for very advanced use-cases."]}),(0,o.jsx)(n.h4,{id:"parameters-2",children:"Parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Context"}),": ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})," - current context to modify"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Field: string"}),": string constant type setting the field on which the new type is added to the arguments map."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Type: any"}),": type to use for the injected field, as well as use as constraint for future overrides of that field."]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"type AppendArguments<Arguments, Field extends string, Type> = {\n  [key in Exclude<keyof Arguments, Field>]: Arguments[key]\n} & {\n  [key in Field]: Type\n}\n\ntype AppendConstraints<Constraints, Backup, Field extends string, Type> = {\n  [key in Exclude<keyof Constraints, Field>]: Constraints[key]\n} & {\n  [key in Exclude<keyof Backup, Field>]: Backup[key]\n} & {\n  [key in Field]: Type\n}\n\ntype AppendStages<Stages, Arguments, Field extends string, Type> = {\n  [key in Exclude<keyof Stages, Field>]: Stages[key]\n} & {\n  [key in Field]: key extends keyof Stages ? Stages[key] : keyof Arguments\n}\n\nexport type AppendStage<\n  Context extends ModularContext,\n  Field extends string,\n  Type,\n> = Pick<Context, 'props'|'ref'> & {\n  arguments: AppendArguments<Context['arguments'], Field, Type>\n  constraints: AppendConstraints<Context['constraints'], Context['_constraints'], Field, Type>\n  stages: AppendStages<Context['stages'], Context['arguments'], Field, Type>\n}\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"type-getargsforcontext-field",children:["Type: ",(0,o.jsx)(n.code,{children:"GetArgsFor<Context, Field>"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["Extract the arguments available for computing a given field, based on the provided context.\nWe either map the arguments against what was saved in ",(0,o.jsx)(n.code,{children:"Context['stages'][Field]"}),", or, if it's the\nfirst time we see this field, we provide the full latest ",(0,o.jsx)(n.code,{children:"Context['arguments']"}),"."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-6",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use that type when you're building a stage function that needs to infer the arguments available in the\n",(0,o.jsx)(n.code,{children:"provide"})," call for a given field."]}),(0,o.jsx)(n.h4,{id:"parameters-3",children:"Parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Context"}),": ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})," - current context to read from"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Field: string"}),": string constant type setting the field for which we want to retrieve arguments"]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export type GetArgsFor<\n  Context extends ModularContext,\n  Field extends string,\n> = Field extends keyof Context['stages']\n  ? Pick<Context['arguments'], Context['stages'][Field]>\n  : Context['arguments']\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"type-getconstraintforcontext-field-default",children:["Type: ",(0,o.jsx)(n.code,{children:"GetConstraintFor<Context, Field, Default>"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsx)(n.p,{children:"Extract the constraints to apply for a given field, to ensure further overrides don't break\nthe initial contract."}),(0,o.jsxs)(n.p,{children:["If the field was not specified in the ",(0,o.jsx)(n.code,{children:"constraints"}),", then we apply the ",(0,o.jsx)(n.code,{children:"Default"})," value as constraint."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-7",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use that type when you're building a stage function, in order to correctly infer the return type of the ",(0,o.jsx)(n.code,{children:"provide"}),"\ncall for the field, while respecting any constraint set for that field in an earlier stage call."]}),(0,o.jsx)(n.h4,{id:"parameters-4",children:"Parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Context"}),": ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})," - current context to read from"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Field: string"}),": string constant type setting the field for which we want to retrieve the constraint"]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export type GetConstraintFor<\n  Context extends ModularContext,\n  Field extends string,\n  Default = any,\n> = Field extends keyof Context['constraints']\n    ? Context['constraints'][Field]\n    : Default\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"type-getvaluegetterforcontext-field-type",children:["Type: ",(0,o.jsx)(n.code,{children:"GetValueGetterFor<Context, Field, Type>"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["Creates a type encapsulating the provided ",(0,o.jsx)(n.code,{children:"Type"}),", either as a raw value or as a function of the ",(0,o.jsx)(n.code,{children:"Field"}),"'s arguments."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-8",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use that type when you're building a stage function, and want to type one of your parameters to allow users to provide\neither a raw value or a value getter computing the value from the arguments map,\nwhich is our ",(0,o.jsx)(n.a,{href:"/docs/usage/writing-custom-stages#getvaluegetterfor-and-wrap-recommended",children:"recommended pattern"}),"."]}),(0,o.jsx)(n.h4,{id:"parameters-5",children:"Parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Context"}),": ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})," - current context to read from"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Field: string"}),": string constant type setting the field for which we want to retrieve the arguments"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Type: any"}),": type of the accepted raw value or accepted return value for the value getter"]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export type GetValueGetterFor<\n  Context extends ModularContext,\n  Field extends string,\n  Type,\n> = Type | ((args: GetArgsFor<Context, Field>) => Type)\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"type-modularcontext-1",children:["Type: ",(0,o.jsx)(n.code,{children:"ModularContext"})]}),"\n",(0,o.jsx)(n.admonition,{type:"ref",children:(0,o.jsxs)(n.p,{children:["See ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})]})}),"\n",(0,o.jsxs)(n.h3,{id:"type-stageparamsfn",children:["Type: ",(0,o.jsx)(n.code,{children:"StageParams<Fn>"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsx)(n.p,{children:"This type takes a stage provider function and extracts its parameters."}),(0,o.jsx)(n.h4,{id:"when-to-use-it-9",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use it to build your ",(0,o.jsx)(n.a,{href:"/docs/usage/writing-custom-stages#providing-a-type-for-registering-the-stage",children:"registration type information"}),".\nIt will automatically infer the parameters taken by your stage function provider."]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export type StageParams<Fn extends (...args: any[]) => any> = Parameters<Fn>\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"type-stagereturnfn",children:["Type: ",(0,o.jsx)(n.code,{children:"StageReturn<Fn>"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["This type takes a stage provider function and computes the return value of the registered stage\nfunction: a ",(0,o.jsx)(n.code,{children:"ModularComponent"})," modified by the stage function with a new field."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-10",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use it to build your ",(0,o.jsx)(n.a,{href:"/docs/usage/writing-custom-stages#providing-a-type-for-registering-the-stage",children:"registration type information"}),".\nIt will automatically infer the return type of the created ",(0,o.jsx)(n.code,{children:"ModularComponent::with{Stage}"})," function."]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export type StageReturn<\n  Fn extends (\n    ...args: any[]\n  ) => (ctx?: any) => { field: string; provide: (args: any) => any },\n> = ModularComponent<\n  AppendStage<\n    NonNullable<Parameters<ReturnType<Fn>>[0]>,\n    ReturnType<ReturnType<Fn>>['field'],\n    ReturnType<ReturnType<ReturnType<Fn>>['provide']>\n  >\n>\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"function-addto",children:["Function: ",(0,o.jsx)(n.code,{children:"addTo"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["Function used to easily build a stage function. See ",(0,o.jsx)(n.a,{href:"/docs/usage/writing-custom-stages#the-addto-helper",children:"Writing custom stages: addTo helper"})," for more\ndetails."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-11",children:"When to use it"}),(0,o.jsx)(n.p,{children:"Use it to build your stage functions."}),(0,o.jsx)(n.h4,{id:"type-parameters-2",children:"Type parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"Context"}),": ",(0,o.jsx)(n.a,{href:"#type-modularcontext",children:(0,o.jsx)(n.code,{children:"ModularContext"})})," - context of the ModularComponent the stage function will be\ncalled on. Should be inferred from your stage function provider."]}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export function addTo<Context extends ModularContext>(): {\n  on<Field extends string>(field: Field): {\n    provide<Stage extends (args: GetArgsFor<Context, Field>) => any>(stage: Stage): (_?: Context) => {\n      field: Field;\n      provide: Stage\n    }\n  }\n}\n"})})]})]}),"\n",(0,o.jsxs)(n.h3,{id:"function-wrap",children:["Function: ",(0,o.jsx)(n.code,{children:"wrap"})]}),"\n",(0,o.jsxs)(n.admonition,{type:"ref",children:[(0,o.jsxs)(n.p,{children:["Function used to easily build a stage function. See ",(0,o.jsx)(n.a,{href:"/docs/usage/writing-custom-stages#getvaluegetterfor-and-wrap-recommended",children:"Writing custom stages: wrap helper"})," for more\ndetails."]}),(0,o.jsx)(n.h4,{id:"when-to-use-it-12",children:"When to use it"}),(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"wrap"})," when your stage function provider receives a parameter of type ",(0,o.jsx)(n.a,{href:"#type-getvaluegetterforcontext-field-type",children:(0,o.jsx)(n.code,{children:"GetValueGetterFor"})}),",\nto safely convert it into a value getter function every time so you can call it with the received args. It\ntakes care of checking if the received value is already a function, or if it is a raw value needing to be wrapped."]}),(0,o.jsx)(n.h4,{id:"function-parameters-2",children:"Function parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useFn: Type | ((args: Args) => Type)"}),": the variable holding either a raw value or a value getter, to be wrapped."]}),"\n"]}),(0,o.jsx)(n.h4,{id:"type-parameters-3",children:"Type parameters"}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Args: arguments of the value getter. Inferred automatically from the passed value if it's a function."}),"\n",(0,o.jsx)(n.li,{children:"Type: type of the value or return type of the value getter. Inferred automatically from the passed value."}),"\n"]}),(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Reveal type"}),(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-tsx",children:"export function wrap<Args, Type>(useFn: Type | ((args: Args) => Type)): (args: Args) => Type\n"})})]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var r=t(6540);const o={},s=r.createContext(o);function i(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);
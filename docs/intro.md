---
sidebar_position: 1
---
# ModularComponent

**ðŸž.with(ðŸ…).with(ðŸ§€) = ðŸ¥ª**

> Delightfully organized and deeply testable React Components

## What are Modular Components

Modular Components are React components built through a modular factory, allowing the
addition of functionality as needed as the component is built.

The modular factory approach is built on top of React hooks, and offers out-of-the-box
composition for building and stub injections for testing.

It offers best-in-class DX through strong typing and easy separation of concern, and is
infinitely extensible thanks to its built-in modular nature.

You can think of it as "higher-order hooks", without the awkward chaining of methods
thanks to the factory pattern.

## Installation

At it simplest, you will need the `@modular-component/core` package to get started with `ModularComponent`.

However, the core module alone does not bring any component capability - it needs plugins,
or extensions, to start shining âœ¨ !

We provide a sensible set of default capabilities through the `@modular-component/default` package.
It is highly recommended to install both for getting started.

```sh
yarn add @modular-component/core @modular-component/default
```

You can then build your component factory by combining the `modularFactory` export from
`@modular-component/core`, and the default set of stages exported as `WithDefaultStages`
from `@modular-component/default`.

```tsx
import { modularFactory } from '@modular-component/core'
import { WithDefaultStages } from '@modular-component/default'

const ModularComponent = modularFactory.extend(WithDefaultStages).build()
```

From there, you can instantiate new components with the `ModularComponent` factory function:

```tsx
const MyFirstModularComponent = ModularComponent<{
  someFlag?: boolean
  someLabel: string
  someValue: number
}>()
  .withDefaultProps({ someFlag: false })
  .withLifecycle(({ props }) => {
    const [someState, setSomeState] = useState(0)

    return { someState }
  })
  .withRender(({ props, lifecycle }) => (
    <>
      <h2>
        {props.someLabel}: {props.someValue}
      </h2>
      <p>Value from state: {lifecycle.someState}</p>
      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>
    </>
  ))
```

## How it works

### The factory pipeline

#### Pipeline stages

The main concept behind the `ModularComponent` approach is the factory pipeline.

At its core, a `ModularComponent` is a set of ordered **stages**, each of which populates
a specific **argument** in a shared object, which gets passed from stage to stage.

The last stage (usually, but not necessarily, the **render stage**) has therefore access
to data computed by every previous stage in the pipeline.

This for instance allows separating any stateful lifecycle computation in a dedicated
stage, and keep the render stage for its main purpose: laying down the markup through JSX.

Here is the "getting started" example, complete with comments explaining
the pipeline system:

```tsx
import { ModularComponent } from '@modular-component/core'

const MyFirstModularComponent = ModularComponent<{
  someFlag?: boolean
  someLabel: string
  someValue: number
}>()
  // .withDefaultProps modifies the `props` argument to mark
  // provided props as NonNullable. Here, `someFlag` will be
  // a `boolean` for all further stages, instead of `boolean | undefined`
  // as it originally was
  .withDefaultProps({ someFlag: false })
  // .withLifecycle receives the modified props from .withDefaultProps
  // It then uses React hooks to construct our component's internal state
  .withLifecycle(({ props }) => {
    const [someState, setSomeState] = useState(0)

    return { someState }
  })
  // Finally, .withRender receives both the up-to-date props and the new
  // lifecycle argument generated by the .withLifecycle stage
  .withRender(({ props, lifecycle }) => (
    <>
      <h2>
        {props.someLabel}: {props.someValue}
      </h2>
      <p>Value from state: {lifecycle.someState}</p>
      <p>Flag from props: {props.someFlag ? 'true' : 'false'}</p>
    </>
  ))
```

#### Adding stages

Internally, a `ModularComponent` keeps an array of ordered stages. Calling a stage
method will either append a new stage to the array, or edit an already existing value.

There are two main stage methods for each available stage type:

- The `with{Stage}` method, as seen is the getting started example, _upsert_ a stage into the array.

  Calling it one time will append the stage at the end of the array; subsequent calls to the same
  stage method will replace the implementation of the stage but keep its position in the pipeline.

  Because of this, it's important that the provided value honors the contract set up by the very
  first call, otherwise it could break downstream stages depending on it.

  When using TypeScript, this is enforced internally, and subsequent calls to an already added stage
  will be narrowed to force honoring previous contracts.

- The `add{Stage}` method _appends_ a new stage into the array.
  It can only be called after the `with` method of the same stage has been used at least once.

  When calling this method, a new stage of the same type is added at the end of the pipeline,
  leaving the previous stages untouched. The argument generated by the newly added stage will
  only be available to downstream stages, and upstream stages will keep receiving the value
  generated by the previous stage of the type.

  Since previous stages are not modified, `add` calls can completely change the value of
  the field without any impact on upstream stages. For the same reason, the TypeScript definition
  is not restricted.

  When calling a `with` method when multiple stages of the same type have been added through `add`,
  the last stage of the type is edited. It's also possible to pass an optional index
  to edit previous stages instead.

#### Manipulating stages

We've seen how the `with` and `add` stage methods allow us to append or edit stages
in our component's pipeline. Additionally, we can further manipulate our pipeline through
two additional stage methods: `at` and `mock`.

- `at{Stage}` stage methods rewind the pipeline to the given stage. If multiple stages of the
  same type were added through the `add` method, the pipeline is rewound to the last stage of the type.
  An optional index can also be provided to rewind to a specific occurrence. All downstream
  stages are dropped, while all upstream stages are kept as-is.
- `mock{Stage}` stage methods replace the value generated by a given stage, skipping any transform
  configured for the stage (see [Writing Extension](./extensions/writing-extensions.md)).

Combining those two methods is especially powerful for testing stages in isolation: `at` allows
dropping downstream stages, while `mock` allows stubbing and controlling upstream stages, leaving
the currently tested stage isolated in the pipeline.

### Generating hooks

Atop of the factory stages seen previously, `ModularComponent`s
also expose methods for converting our component to a hook:

- `asHook`: extract the stages as a custom hook, returning the map of arguments.
  This is used internally when calling the generated component, but can also be
  useful in other situations like tests, or the need to generate a shared hook
  consuming application context, such as a global store for which a stage exists.
- `asUse{Argument}`: creates a custom hook running our pipeline and returning the
  value of one specific argument. Useful in combination with `at{Stage}` to test 
  the returned value of a given stage easily.

Combining those hook methods with `at` and `mock` stage methods can be very powerful in testing scenarios. For instance,
one can extract the lifecycle hook of a component by chaining them:

```tsx
const useLifecycle = MyComponent.atLifecycle().asUseLifecycle()
```

Or one could mock the lifecycle entirely to test the render:

```tsx
const OnlyRender = MyComponent.mockLifecycle({
  fromLifecycle: 'hello world',
})
```
